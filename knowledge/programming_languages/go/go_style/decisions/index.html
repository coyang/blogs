
<!DOCTYPE html>

<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="Coyang's Personal Blogs" name="description"/>
<meta content="coyang" name="author"/>
<link href="https://coyang.top/knowledge/programming_languages/go/go_style/decisions/" rel="canonical"/>
<link href="../../../../../images/logo/COYANG-logos_transparent.png" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.9" name="generator"/>
<title>Decisions - COYANG</title>
<link href="../../../../../assets/stylesheets/main.4af4bdda.min.css" rel="stylesheet"/>
<script>__md_scope=new URL("../../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
</head>
<body dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#go-style-decisions">
          Skip to content
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="Header" class="md-header__inner md-grid">
<a aria-label="COYANG" class="md-header__button md-logo" data-md-component="logo" href="../../../../.." title="COYANG">
<img alt="logo" src="../../../../../images/logo/COYANG-logos_white.png"/>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            COYANG
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Decisions
            
          </span>
</div>
</div>
</div>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="Search" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="Search" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path></svg>
</label>
<nav aria-label="Search" class="md-search__options">
<button aria-label="Clear" class="md-search__icon md-icon" tabindex="-1" title="Clear" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
<div class="md-search__suggest" data-md-component="search-suggest"></div>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            Initializing search
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="Tabs" class="md-tabs" data-md-component="tabs">
<div class="md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../../..">
        
  
    
  
  Home

      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../../../ai/rag/rag/">
          
  
  AI

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../../">
          
  
  Knowledge

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../../../musings/">
        
  
    
  
  Musings

      </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../../../../about/">
        
  
    
  
  About

      </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="COYANG" class="md-nav__button md-logo" data-md-component="logo" href="../../../../.." title="COYANG">
<img alt="logo" src="../../../../../images/logo/COYANG-logos_white.png"/>
</a>
    COYANG
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../../../..">
<span class="md-ellipsis">
    Home
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../../../../ai/rag/rag/">
<span class="md-ellipsis">
    AI
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../../../">
<span class="md-ellipsis">
    Knowledge
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../../../musings/">
<span class="md-ellipsis">
    Musings
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../../../../about/">
<span class="md-ellipsis">
    About
    
  </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#about">
<span class="md-ellipsis">
      About
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#naming">
<span class="md-ellipsis">
      Naming
    </span>
</a>
<nav aria-label="Naming" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#underscores">
<span class="md-ellipsis">
      Underscores
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#package-names">
<span class="md-ellipsis">
      Package names
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#receiver-names">
<span class="md-ellipsis">
      Receiver names
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#constant-names">
<span class="md-ellipsis">
      Constant names
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#initialisms">
<span class="md-ellipsis">
      Initialisms
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#getters">
<span class="md-ellipsis">
      Getters
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#variable-names">
<span class="md-ellipsis">
      Variable names
    </span>
</a>
<nav aria-label="Variable names" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#single-letter-variable-names">
<span class="md-ellipsis">
      Single-letter variable names
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#repetition">
<span class="md-ellipsis">
      Repetition
    </span>
</a>
<nav aria-label="Repetition" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#package-vs-exported-symbol-name">
<span class="md-ellipsis">
      Package vs. exported symbol name
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#variable-name-vs-type">
<span class="md-ellipsis">
      Variable name vs. type
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#external-context-vs-local-names">
<span class="md-ellipsis">
      External context vs. local names
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#commentary">
<span class="md-ellipsis">
      Commentary
    </span>
</a>
<nav aria-label="Commentary" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#comment-line-length">
<span class="md-ellipsis">
      Comment line length
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#doc-comments">
<span class="md-ellipsis">
      Doc comments
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#comment-sentences">
<span class="md-ellipsis">
      Comment sentences
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#examples">
<span class="md-ellipsis">
      Examples
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#named-result-parameters">
<span class="md-ellipsis">
      Named result parameters
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#package-comments">
<span class="md-ellipsis">
      Package comments
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#imports">
<span class="md-ellipsis">
      Imports
    </span>
</a>
<nav aria-label="Imports" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#import-renaming">
<span class="md-ellipsis">
      Import renaming
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#import-grouping">
<span class="md-ellipsis">
      Import grouping
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#import-blank-import-_">
<span class="md-ellipsis">
      Import “blank” (import _)
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#import-dot-import">
<span class="md-ellipsis">
      Import “dot” (import .)
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#errors">
<span class="md-ellipsis">
      Errors
    </span>
</a>
<nav aria-label="Errors" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#returning-errors">
<span class="md-ellipsis">
      Returning errors
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#error-strings">
<span class="md-ellipsis">
      Error strings
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#handle-errors">
<span class="md-ellipsis">
      Handle errors
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#in-band-errors">
<span class="md-ellipsis">
      In-band errors
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indent-error-flow">
<span class="md-ellipsis">
      Indent error flow
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#language">
<span class="md-ellipsis">
      Language
    </span>
</a>
<nav aria-label="Language" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#literal-formatting">
<span class="md-ellipsis">
      Literal formatting
    </span>
</a>
<nav aria-label="Literal formatting" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#field-names">
<span class="md-ellipsis">
      Field names
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#matching-braces">
<span class="md-ellipsis">
      Matching braces
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cuddled-braces">
<span class="md-ellipsis">
      Cuddled braces
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#repeated-type-names">
<span class="md-ellipsis">
      Repeated type names
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#zero-value-fields">
<span class="md-ellipsis">
      Zero-value fields
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nil-slices">
<span class="md-ellipsis">
      Nil slices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indentation-confusion">
<span class="md-ellipsis">
      Indentation confusion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function-formatting">
<span class="md-ellipsis">
      Function formatting
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#conditionals-and-loops">
<span class="md-ellipsis">
      Conditionals and loops
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#copying">
<span class="md-ellipsis">
      Copying
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#dont-panic">
<span class="md-ellipsis">
      Don’t panic
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#must-functions">
<span class="md-ellipsis">
      Must functions
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#goroutine-lifetimes">
<span class="md-ellipsis">
      Goroutine lifetimes
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#interfaces">
<span class="md-ellipsis">
      Interfaces
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#generics">
<span class="md-ellipsis">
      Generics
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#pass-values">
<span class="md-ellipsis">
      Pass values
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#receiver-type">
<span class="md-ellipsis">
      Receiver type
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#switch-and-break">
<span class="md-ellipsis">
      switch and break
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#synchronous-functions">
<span class="md-ellipsis">
      Synchronous functions
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#type-aliases">
<span class="md-ellipsis">
      Type aliases
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#use-q">
<span class="md-ellipsis">
      Use %q
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#use-any">
<span class="md-ellipsis">
      Use any
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#common-libraries">
<span class="md-ellipsis">
      Common libraries
    </span>
</a>
<nav aria-label="Common libraries" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#flags">
<span class="md-ellipsis">
      Flags
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#logging">
<span class="md-ellipsis">
      Logging
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#contexts">
<span class="md-ellipsis">
      Contexts
    </span>
</a>
<nav aria-label="Contexts" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#custom-contexts">
<span class="md-ellipsis">
      Custom contexts
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cryptorand">
<span class="md-ellipsis">
      crypto/rand
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#useful-test-failures">
<span class="md-ellipsis">
      Useful test failures
    </span>
</a>
<nav aria-label="Useful test failures" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#assertion-libraries">
<span class="md-ellipsis">
      Assertion libraries
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#identify-the-function">
<span class="md-ellipsis">
      Identify the function
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#identify-the-input">
<span class="md-ellipsis">
      Identify the input
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#got-before-want">
<span class="md-ellipsis">
      Got before want
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#full-structure-comparisons">
<span class="md-ellipsis">
      Full structure comparisons
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#compare-stable-results">
<span class="md-ellipsis">
      Compare stable results
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#keep-going">
<span class="md-ellipsis">
      Keep going
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#equality-comparison-and-diffs">
<span class="md-ellipsis">
      Equality comparison and diffs
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#level-of-detail">
<span class="md-ellipsis">
      Level of detail
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#print-diffs">
<span class="md-ellipsis">
      Print diffs
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#test-error-semantics">
<span class="md-ellipsis">
      Test error semantics
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#test-structure">
<span class="md-ellipsis">
      Test structure
    </span>
</a>
<nav aria-label="Test structure" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#subtests">
<span class="md-ellipsis">
      Subtests
    </span>
</a>
<nav aria-label="Subtests" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#subtest-names">
<span class="md-ellipsis">
      Subtest names
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<div><h1 id="go-style-decisions">Go Style Decisions<a class="headerlink" href="#go-style-decisions" title="Permanent link">¶</a></h1>
<p>https://google.github.io/styleguide/go/decisions</p>
<p><a href="index">Overview</a> | <a href="guide">Guide</a> | <a href="decisions">Decisions</a> |
<a href="best-practices">Best practices</a></p>
<!--
-->
<p>{% raw %}</p>
<p><strong>Note:</strong> This is part of a series of documents that outline <a href="index">Go Style</a>
at Google. This document is <strong><a href="index#normative">normative</a> but not
<a href="index#canonical">canonical</a></strong>, and is subordinate to the
<a href="guide">core style guide</a>. See <a href="index#about">the overview</a> for more information.</p>
<p><a id="about"></a></p>
<h2 id="about">About<a class="headerlink" href="#about" title="Permanent link">¶</a></h2>
<p>This document contains style decisions intended to unify and provide standard
guidance, explanations, and examples for the advice given by the Go readability
mentors.</p>
<p>This document is <strong>not exhaustive</strong> and will grow over time. In cases where
<a href="guide">the core style guide</a> contradicts the advice given here, <strong>the style
guide takes precedence</strong>, and this document should be updated accordingly.</p>
<p>See <a href="https://google.github.io/styleguide/go#about">the Overview</a> for the full
set of Go Style documents.</p>
<p>The following sections have moved from style decisions to another part of the
guide:</p>
<ul>
<li>
<p><strong>MixedCaps</strong>: see <a href="guide#mixed-caps">guide#mixed-caps</a>
<a id="mixed-caps"></a></p>
</li>
<li>
<p><strong>Formatting</strong>: see <a href="guide#formatting">guide#formatting</a>
<a id="formatting"></a></p>
</li>
<li>
<p><strong>Line Length</strong>: see <a href="guide#line-length">guide#line-length</a>
<a id="line-length"></a></p>
</li>
</ul>
<p><a id="naming"></a></p>
<h2 id="naming">Naming<a class="headerlink" href="#naming" title="Permanent link">¶</a></h2>
<p>See the naming section within <a href="guide#naming">the core style guide</a> for
overarching guidance on naming. The following sections provide further
clarification on specific areas within naming.</p>
<p><a id="underscores"></a></p>
<h3 id="underscores">Underscores<a class="headerlink" href="#underscores" title="Permanent link">¶</a></h3>
<p>Names in Go should in general not contain underscores. There are three
exceptions to this principle:</p>
<ol>
<li>Package names that are only imported by generated code may contain
    underscores. See <a href="#package-names">package names</a> for more detail around how
    to choose multi-word package names.</li>
<li>Test, Benchmark and Example function names within <code>*_test.go</code> files may
    include underscores.</li>
<li>Low-level libraries that interoperate with the operating system or cgo may
    reuse identifiers, as is done in [<code>syscall</code>]. This is expected to be very
    rare in most codebases.</li>
</ol>
<p><a id="package-names"></a></p>
<h3 id="package-names">Package names<a class="headerlink" href="#package-names" title="Permanent link">¶</a></h3>
<p><a id="TOC-PackageNames"></a></p>
<p>Go package names should be short and contain only lowercase letters. A package
name composed of multiple words should be left unbroken in all lowercase. For
example, the package [<code>tabwriter</code>] is not named <code>tabWriter</code>, <code>TabWriter</code>, or
<code>tab_writer</code>.</p>
<p>Avoid selecting package names that are likely to be <a href="best-practices#shadowing">shadowed</a> by commonly used
local variable names. For example, <code>usercount</code> is a better package name than
<code>count</code>, since <code>count</code> is a commonly used variable name.</p>
<p>Go package names should not have underscores. If you need to import a package
that does have one in its name (usually from generated or third party code), it
must be renamed at import time to a name that is suitable for use in Go code.</p>
<p>An exception to this is that package names that are only imported by generated
code may contain underscores. Specific examples include:</p>
<ul>
<li>
<p>Using the <code>_test</code> suffix for an external test package, for example an
    integration test</p>
</li>
<li>
<p>Using the <code>_test</code> suffix for
    <a href="https://go.dev/blog/examples">package-level documentation examples</a></p>
</li>
</ul>
<p>Avoid uninformative package names like <code>util</code>, <code>utility</code>, <code>common</code>, <code>helper</code>,
and so on. See more about
<a href="best-practices#util-packages">so-called “utility packages”</a>.</p>
<p>When an imported package is renamed (e.g. <code>import foopb
"path/to/foo_go_proto"</code>), the local name for the package must comply with the
rules above, as the local name dictates how the symbols in the package are
referenced in the file. If a given import is renamed in multiple files,
particularly in the same or nearby packages, the same local name should be used
wherever possible for consistency.</p>
<!--#include file="/go/g3doc/style/includes/special-name-exception.md"-->
<p>See also: <a href="https://go.dev/blog/package-names">Go blog post about package names</a>.</p>
<p><a id="receiver-names"></a></p>
<h3 id="receiver-names">Receiver names<a class="headerlink" href="#receiver-names" title="Permanent link">¶</a></h3>
<p><a id="TOC-ReceiverNames"></a></p>
<p><a href="https://golang.org/ref/spec#Method_declarations">Receiver</a> variable names must be:</p>
<ul>
<li>Short (usually one or two letters in length)</li>
<li>Abbreviations for the type itself</li>
<li>Applied consistently to every receiver for that type</li>
</ul>
<table>
<thead>
<tr>
<th>Long Name</th>
<th>Better Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>func (tray Tray)</code></td>
<td><code>func (t Tray)</code></td>
</tr>
<tr>
<td><code>func (info *ResearchInfo)</code></td>
<td><code>func (ri *ResearchInfo)</code></td>
</tr>
<tr>
<td><code>func (this *ReportWriter)</code></td>
<td><code>func (w *ReportWriter)</code></td>
</tr>
<tr>
<td><code>func (self *Scanner)</code></td>
<td><code>func (s *Scanner)</code></td>
</tr>
</tbody>
</table>
<p><a id="constant-names"></a></p>
<h3 id="constant-names">Constant names<a class="headerlink" href="#constant-names" title="Permanent link">¶</a></h3>
<p>Constant names must use <a href="guide#mixed-caps">MixedCaps</a> like all other names in Go. (<a href="https://tour.golang.org/basics/3">Exported</a>
constants start with uppercase, while unexported constants start with
lowercase.) This applies even when it breaks conventions in other languages.
Constant names should not be a derivative of their values and should instead
explain what the value denotes.</p>
<pre><code class="language-go">// Good:
const MaxPacketSize = 512

const (
    ExecuteBit = 1 &lt;&lt; iota
    WriteBit
    ReadBit
)
</code></pre>
<p>Do not use non-MixedCaps constant names or constants with a <code>K</code> prefix.</p>
<pre><code class="language-go">// Bad:
const MAX_PACKET_SIZE = 512
const kMaxBufferSize = 1024
const KMaxUsersPergroup = 500
</code></pre>
<p>Name constants based on their role, not their values. If a constant does not
have a role apart from its value, then it is unnecessary to define it as a
constant.</p>
<pre><code class="language-go">// Bad:
const Twelve = 12

const (
    UserNameColumn = "username"
    GroupColumn    = "group"
)
</code></pre>
<!--#include file="/go/g3doc/style/includes/special-name-exception.md"-->
<p><a id="initialisms"></a></p>
<h3 id="initialisms">Initialisms<a class="headerlink" href="#initialisms" title="Permanent link">¶</a></h3>
<p><a id="TOC-Initialisms"></a></p>
<p>Words in names that are initialisms or acronyms (e.g., <code>URL</code> and <code>NATO</code>) should
have the same case. <code>URL</code> should appear as <code>URL</code> or <code>url</code> (as in <code>urlPony</code>, or
<code>URLPony</code>), never as <code>Url</code>. This also applies to <code>ID</code> when it is short for
“identifier”; write <code>appID</code> instead of <code>appId</code>.</p>
<ul>
<li>In names with multiple initialisms (e.g. <code>XMLAPI</code> because it contains <code>XML</code>
    and <code>API</code>), each letter within a given initialism should have the same case,
    but each initialism in the name does not need to have the same case.</li>
<li>In names with an initialism containing a lowercase letter (e.g. <code>DDoS</code>,
    <code>iOS</code>, <code>gRPC</code>), the initialism should appear as it would in standard prose,
    unless you need to change the first letter for the sake of <a href="https://golang.org/ref/spec#Exported_identifiers">exportedness</a>.
    In these cases, the entire initialism should be the same case (e.g. <code>ddos</code>,
    <code>IOS</code>, <code>GRPC</code>).</li>
</ul>
<!-- Keep this table narrow. If it must grow wider, replace with a list. -->
<table>
<thead>
<tr>
<th>Initialism(s)</th>
<th>Scope</th>
<th>Correct</th>
<th>Incorrect</th>
</tr>
</thead>
<tbody>
<tr>
<td>XML API</td>
<td>Exported</td>
<td><code>XMLAPI</code></td>
<td><code>XmlApi</code>, <code>XMLApi</code>, <code>XmlAPI</code>, <code>XMLapi</code></td>
</tr>
<tr>
<td>XML API</td>
<td>Unexported</td>
<td><code>xmlAPI</code></td>
<td><code>xmlapi</code>, <code>xmlApi</code></td>
</tr>
<tr>
<td>iOS</td>
<td>Exported</td>
<td><code>IOS</code></td>
<td><code>Ios</code>, <code>IoS</code></td>
</tr>
<tr>
<td>iOS</td>
<td>Unexported</td>
<td><code>iOS</code></td>
<td><code>ios</code></td>
</tr>
<tr>
<td>gRPC</td>
<td>Exported</td>
<td><code>GRPC</code></td>
<td><code>Grpc</code></td>
</tr>
<tr>
<td>gRPC</td>
<td>Unexported</td>
<td><code>gRPC</code></td>
<td><code>grpc</code></td>
</tr>
<tr>
<td>DDoS</td>
<td>Exported</td>
<td><code>DDoS</code></td>
<td><code>DDOS</code>, <code>Ddos</code></td>
</tr>
<tr>
<td>DDoS</td>
<td>Unexported</td>
<td><code>ddos</code></td>
<td><code>dDoS</code>, <code>dDOS</code></td>
</tr>
</tbody>
</table>
<!--#include file="/go/g3doc/style/includes/special-name-exception.md"-->
<p><a id="getters"></a></p>
<h3 id="getters">Getters<a class="headerlink" href="#getters" title="Permanent link">¶</a></h3>
<p><a id="TOC-Getters"></a></p>
<p>Function and method names should not use a <code>Get</code> or <code>get</code> prefix, unless the
underlying concept uses the word “get” (e.g. an HTTP GET). Prefer starting the
name with the noun directly, for example use <code>Counts</code> over <code>GetCounts</code>.</p>
<p>If the function involves performing a complex computation or executing a remote
call, a different word like <code>Compute</code> or <code>Fetch</code> can be used in place of <code>Get</code>,
to make it clear to a reader that the function call may take time and could
block or fail.</p>
<!--#include file="/go/g3doc/style/includes/special-name-exception.md"-->
<p><a id="variable-names"></a></p>
<h3 id="variable-names">Variable names<a class="headerlink" href="#variable-names" title="Permanent link">¶</a></h3>
<p><a id="TOC-VariableNames"></a></p>
<p>The general rule of thumb is that the length of a name should be proportional to
the size of its scope and inversely proportional to the number of times that it
is used within that scope. A variable created at file scope may require multiple
words, whereas a variable scoped to a single inner block may be a single word or
even just a character or two, to keep the code clear and avoid extraneous
information.</p>
<p>Here is a rough baseline. These numeric guidelines are not strict rules. Apply
judgement based on context, <a href="guide#clarity">clarity</a>, and <a href="guide#concision">concision</a>.</p>
<ul>
<li>A small scope is one in which one or two small operations are performed, say
    1-7 lines.</li>
<li>A medium scope is a few small or one large operation, say 8-15 lines.</li>
<li>A large scope is one or a few large operations, say 15-25 lines.</li>
<li>A very large scope is anything that spans more than a page (say, more than
    25 lines).</li>
</ul>
<p>A name that might be perfectly clear (e.g., <code>c</code> for a counter) within a small
scope could be insufficient in a larger scope and would require clarification to
remind the reader of its purpose further along in the code. A scope in which
there are many variables, or variables that represent similar values or
concepts, may necessitate longer variable names than the scope suggests.</p>
<p>The specificity of the concept can also help to keep a variable’s name concise.
For example, assuming there is only a single database in use, a short variable
name like <code>db</code> that might normally be reserved for very small scopes may remain
perfectly clear even if the scope is very large. In this case, a single word
<code>database</code> is likely acceptable based on the size of the scope, but is not
required as <code>db</code> is a very common shortening for the word with few alternate
interpretations.</p>
<p>The name of a local variable should reflect what it contains and how it is being
used in the current context, rather than where the value originated. For
example, it is often the case that the best local variable name is not the same
as the struct or protocol buffer field name.</p>
<p>In general:</p>
<ul>
<li>Single-word names like <code>count</code> or <code>options</code> are a good starting point.</li>
<li>Additional words can be added to disambiguate similar names, for example
    <code>userCount</code> and <code>projectCount</code>.</li>
<li>Do not simply drop letters to save typing. For example <code>Sandbox</code> is
    preferred over <code>Sbx</code>, particularly for exported names.</li>
<li>Omit <a href="#repetitive-with-type">types and type-like words</a> from most variable names.<ul>
<li>For a number, <code>userCount</code> is a better name than <code>numUsers</code> or
    <code>usersInt</code>.</li>
<li>For a slice, <code>users</code> is a better name than <code>userSlice</code>.</li>
<li>It is acceptable to include a type-like qualifier if there are two
    versions of a value in scope, for example you might have an input stored
    in <code>ageString</code> and use <code>age</code> for the parsed value.</li>
</ul>
</li>
<li>Omit words that are clear from the <a href="#repetitive-in-context">surrounding context</a>. For example, in
    the implementation of a <code>UserCount</code> method, a local variable called
    <code>userCount</code> is probably redundant; <code>count</code>, <code>users</code>, or even <code>c</code> are just as
    readable.</li>
</ul>
<p><a id="v"></a></p>
<h4 id="single-letter-variable-names">Single-letter variable names<a class="headerlink" href="#single-letter-variable-names" title="Permanent link">¶</a></h4>
<p>Single-letter variable names can be a useful tool to minimize
<a href="#repetition">repetition</a>, but can also make code needlessly opaque. Limit their
use to instances where the full word is obvious and where it would be repetitive
for it to appear in place of the single-letter variable.</p>
<p>In general:</p>
<ul>
<li>For a <a href="#receiver-names">method receiver variable</a>, a one-letter or two-letter name is
    preferred.</li>
<li>Using familiar variable names for common types is often helpful:<ul>
<li><code>r</code> for an <code>io.Reader</code> or <code>*http.Request</code></li>
<li><code>w</code> for an <code>io.Writer</code> or <code>http.ResponseWriter</code></li>
</ul>
</li>
<li>Single-letter identifiers are acceptable as integer loop variables,
    particularly for indices (e.g., <code>i</code>) and coordinates (e.g., <code>x</code> and <code>y</code>).</li>
<li>Abbreviations can be acceptable loop identifiers when the scope is short,
    for example <code>for _, n := range nodes { ... }</code>.</li>
</ul>
<p><a id="repetition"></a></p>
<h3 id="repetition">Repetition<a class="headerlink" href="#repetition" title="Permanent link">¶</a></h3>
<!--
Note to future editors:

Do not use the term "stutter" to refer to cases when a name is repetitive.
-->
<p>A piece of Go source code should avoid unnecessary repetition. One common source
of this is repetitive names, which often include unnecessary words or repeat
their context or type. Code itself can also be unnecessarily repetitive if the
same or a similar code segment appears multiple times in close proximity.</p>
<p>Repetitive naming can come in many forms, including:</p>
<p><a id="repetitive-with-package"></a></p>
<h4 id="package-vs-exported-symbol-name">Package vs. exported symbol name<a class="headerlink" href="#package-vs-exported-symbol-name" title="Permanent link">¶</a></h4>
<p>When naming exported symbols, the name of the package is always visible outside
your package, so redundant information between the two should be reduced or
eliminated. If a package exports only one type and it is named after the package
itself, the canonical name for the constructor is <code>New</code> if one is required.</p>
<blockquote>
<p><strong>Examples:</strong> Repetitive Name -&gt; Better Name</p>
<ul>
<li><code>widget.NewWidget</code> -&gt; <code>widget.New</code></li>
<li><code>widget.NewWidgetWithName</code> -&gt; <code>widget.NewWithName</code></li>
<li><code>db.LoadFromDatabase</code> -&gt; <code>db.Load</code></li>
<li><code>goatteleportutil.CountGoatsTeleported</code> -&gt; <code>gtutil.CountGoatsTeleported</code>
    or <code>goatteleport.Count</code></li>
<li><code>myteampb.MyTeamMethodRequest</code> -&gt; <code>mtpb.MyTeamMethodRequest</code> or
    <code>myteampb.MethodRequest</code></li>
</ul>
</blockquote>
<p><a id="repetitive-with-type"></a></p>
<h4 id="variable-name-vs-type">Variable name vs. type<a class="headerlink" href="#variable-name-vs-type" title="Permanent link">¶</a></h4>
<p>The compiler always knows the type of a variable, and in most cases it is also
clear to the reader what type a variable is by how it is used. It is only
necessary to clarify the type of a variable if its value appears twice in the
same scope.</p>
<table>
<thead>
<tr>
<th>Repetitive Name</th>
<th>Better Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>var numUsers int</code></td>
<td><code>var users int</code></td>
</tr>
<tr>
<td><code>var nameString string</code></td>
<td><code>var name string</code></td>
</tr>
<tr>
<td><code>var primaryProject *Project</code></td>
<td><code>var primary *Project</code></td>
</tr>
</tbody>
</table>
<p>If the value appears in multiple forms, this can be clarified either with an
extra word like <code>raw</code> and <code>parsed</code> or with the underlying representation:</p>
<pre><code class="language-go">// Good:
limitStr := r.FormValue("limit")
limit, err := strconv.Atoi(limitStr)
</code></pre>
<pre><code class="language-go">// Good:
limitRaw := r.FormValue("limit")
limit, err := strconv.Atoi(limitRaw)
</code></pre>
<p><a id="repetitive-in-context"></a></p>
<h4 id="external-context-vs-local-names">External context vs. local names<a class="headerlink" href="#external-context-vs-local-names" title="Permanent link">¶</a></h4>
<p>Names that include information from their surrounding context often create extra
noise without benefit. The package name, method name, type name, function name,
import path, and even filename can all provide context that automatically
qualifies all names within.</p>
<pre><code class="language-go">// Bad:
// In package "ads/targeting/revenue/reporting"
type AdsTargetingRevenueReport struct{}

func (p *Project) ProjectName() string
</code></pre>
<pre><code class="language-go">// Good:
// In package "ads/targeting/revenue/reporting"
type Report struct{}

func (p *Project) Name() string
</code></pre>
<pre><code class="language-go">// Bad:
// In package "sqldb"
type DBConnection struct{}
</code></pre>
<pre><code class="language-go">// Good:
// In package "sqldb"
type Connection struct{}
</code></pre>
<pre><code class="language-go">// Bad:
// In package "ads/targeting"
func Process(in *pb.FooProto) *Report {
    adsTargetingID := in.GetAdsTargetingID()
}
</code></pre>
<pre><code class="language-go">// Good:
// In package "ads/targeting"
func Process(in *pb.FooProto) *Report {
    id := in.GetAdsTargetingID()
}
</code></pre>
<p>Repetition should generally be evaluated in the context of the user of the
symbol, rather than in isolation. For example, the following code has lots of
names that may be fine in some circumstances, but redundant in context:</p>
<pre><code class="language-go">// Bad:
func (db *DB) UserCount() (userCount int, err error) {
    var userCountInt64 int64
    if dbLoadError := db.LoadFromDatabase("count(distinct users)", &amp;userCountInt64); dbLoadError != nil {
        return 0, fmt.Errorf("failed to load user count: %s", dbLoadError)
    }
    userCount = int(userCountInt64)
    return userCount, nil
}
</code></pre>
<p>Instead, information about names that are clear from context or usage can often
be omitted:</p>
<pre><code class="language-go">// Good:
func (db *DB) UserCount() (int, error) {
    var count int64
    if err := db.Load("count(distinct users)", &amp;count); err != nil {
        return 0, fmt.Errorf("failed to load user count: %s", err)
    }
    return int(count), nil
}
</code></pre>
<p><a id="commentary"></a></p>
<h2 id="commentary">Commentary<a class="headerlink" href="#commentary" title="Permanent link">¶</a></h2>
<p>The conventions around commentary (which include what to comment, what style to
use, how to provide runnable examples, etc.) are intended to support the
experience of reading the documentation of a public API. See
<a href="http://golang.org/doc/effective_go.html#commentary">Effective Go</a> for more
information.</p>
<p>The best practices document’s section on <a href="best-practices#documentation-conventions">documentation conventions</a> discusses
this further.</p>
<p><strong>Best Practice:</strong> Use <a href="best-practices#documentation-preview">doc preview</a> during development and code review to see
whether the documentation and runnable examples are useful and are presented the
way you expect them to be.</p>
<p><strong>Tip:</strong> Godoc uses very little special formatting; lists and code snippets
should usually be indented to avoid linewrapping. Apart from indentation,
decoration should generally be avoided.</p>
<p><a id="comment-line-length"></a></p>
<h3 id="comment-line-length">Comment line length<a class="headerlink" href="#comment-line-length" title="Permanent link">¶</a></h3>
<p>Ensure that commentary is readable from source even on narrow screens.</p>
<p>When a comment gets too long, it is recommended to wrap it into multiple
single-line comments. When possible, aim for comments that will read well on an
80-column wide terminal, however this is not a hard cut-off; there is no fixed
line length limit for comments in Go. The standard library, for example, often
chooses to break a comment based on punctuation, which sometimes leaves the
individual lines closer to the 60-70 character mark.</p>
<p>There is plenty of existing code in which comments exceed 80 characters in
length. This guidance should not be used as a justification to change such code
as part of a readability review (see <a href="guide#consistency">consistency</a>), though
teams are encouraged to opportunistically update comments to follow this
guideline as a part of other refactors. The primary goal of this guideline is to
ensure that all Go readability mentors make the same recommendation when and if
recommendations are made.</p>
<p>See this <a href="https://blog.golang.org/godoc-documenting-go-code">post from The Go Blog on documentation</a> for more on commentary.</p>
<pre><code class="language-text"># Good:
// This is a comment paragraph.
// The length of individual lines doesn't matter in Godoc;
// but the choice of wrapping makes it easy to read on narrow screens.
//
// Don't worry too much about the long URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
//
// Similarly, if you have other information that is made awkward
// by too many line breaks, use your judgment and include a long line
// if it helps rather than hinders.
</code></pre>
<p>Avoid comments that will wrap repeatedly on small screens, which is a poor
reader experience.</p>
<pre><code class="language-text"># Bad:
// This is a comment paragraph. The length of individual lines doesn't matter in
Godoc;
// but the choice of wrapping causes jagged lines on narrow screens or in code
review,
// which can be annoying, especially when in a comment block that will wrap
repeatedly.
//
// Don't worry too much about the long URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
</code></pre>
<p><a id="doc-comments"></a></p>
<h3 id="doc-comments">Doc comments<a class="headerlink" href="#doc-comments" title="Permanent link">¶</a></h3>
<p><a id="TOC-DocComments"></a></p>
<p>All top-level exported names must have doc comments, as should unexported type
or function declarations with unobvious behavior or meaning. These comments
should be <a href="#comment-sentences">full sentences</a> that begin with the name of the object being
described. An article (“a”, “an”, “the”) can precede the name to make it read
more naturally.</p>
<pre><code class="language-go">// Good:
// A Request represents a request to run a command.
type Request struct { ...

// Encode writes the JSON encoding of req to w.
func Encode(w io.Writer, req *Request) { ...
</code></pre>
<p>Doc comments appear in <a href="https://pkg.go.dev/">Godoc</a> and are surfaced by IDEs,
and therefore should be written for anyone using the package.</p>
<p>A documentation comment applies to the following symbol, or the group of fields
if it appears in a struct.</p>
<pre><code class="language-go">// Good:
// Options configure the group management service.
type Options struct {
    // General setup:
    Name  string
    Group *FooGroup

    // Dependencies:
    DB *sql.DB

    // Customization:
    LargeGroupThreshold int // optional; default: 10
    MinimumMembers      int // optional; default: 2
}
</code></pre>
<p><strong>Best Practice:</strong> If you have doc comments for unexported code, follow the same
custom as if it were exported (namely, starting the comment with the unexported
name). This makes it easy to export it later by simply replacing the unexported
name with the newly-exported one across both comments and code.</p>
<p><a id="comment-sentences"></a></p>
<h3 id="comment-sentences">Comment sentences<a class="headerlink" href="#comment-sentences" title="Permanent link">¶</a></h3>
<p><a id="TOC-CommentSentences"></a></p>
<p>Comments that are complete sentences should be capitalized and punctuated like
standard English sentences. (As an exception, it is okay to begin a sentence
with an uncapitalized identifier name if it is otherwise clear. Such cases are
probably best done only at the beginning of a paragraph.)</p>
<p>Comments that are sentence fragments have no such requirements for punctuation
or capitalization.</p>
<p><a href="#doc-comments">Documentation comments</a> should always be complete sentences, and as such should
always be capitalized and punctuated. Simple end-of-line comments (especially
for struct fields) can be simple phrases that assume the field name is the
subject.</p>
<pre><code class="language-go">// Good:
// A Server handles serving quotes from the collected works of Shakespeare.
type Server struct {
    // BaseDir points to the base directory under which Shakespeare's works are stored.
    //
    // The directory structure is expected to be the following:
    //   {BaseDir}/manifest.json
    //   {BaseDir}/{name}/{name}-part{number}.txt
    BaseDir string

    WelcomeMessage  string // displayed when user logs in
    ProtocolVersion string // checked against incoming requests
    PageLength      int    // lines per page when printing (optional; default: 20)
}
</code></pre>
<p><a id="examples"></a></p>
<h3 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">¶</a></h3>
<p><a id="TOC-Examples"></a></p>
<p>Packages should clearly document their intended usage. Try to provide a
<a href="http://blog.golang.org/examples">runnable example</a>; examples show up in Godoc. Runnable examples belong in the
test file, not the production source file. See this example (<a href="https://pkg.go.dev/time#example-Duration">Godoc</a>, <a href="https://cs.opensource.google/go/go/+/HEAD:src/time/example_test.go">source</a>).</p>
<p>If it isn’t feasible to provide a runnable example, example code can be provided
within code comments. As with other code and command-line snippets in comments,
it should follow standard formatting conventions.</p>
<p><a id="named-result-parameters"></a></p>
<h3 id="named-result-parameters">Named result parameters<a class="headerlink" href="#named-result-parameters" title="Permanent link">¶</a></h3>
<p><a id="TOC-NamedResultParameters"></a></p>
<p>When naming parameters, consider how function signatures appear in Godoc. The
name of the function itself and the type of the result parameters are often
sufficiently clear.</p>
<pre><code class="language-go">// Good:
func (n *Node) Parent1() *Node
func (n *Node) Parent2() (*Node, error)
</code></pre>
<p>If a function returns two or more parameters of the same type, adding names can
be useful.</p>
<pre><code class="language-go">// Good:
func (n *Node) Children() (left, right *Node, err error)
</code></pre>
<p>If the caller must take action on particular result parameters, naming them can
help suggest what the action is:</p>
<pre><code class="language-go">// Good:
// WithTimeout returns a context that will be canceled no later than d duration
// from now.
//
// The caller must arrange for the returned cancel function to be called when
// the context is no longer needed to prevent a resource leak.
func WithTimeout(parent Context, d time.Duration) (ctx Context, cancel func())
</code></pre>
<p>In the code above, cancellation is a particular action a caller must take.
However, were the result parameters written as <code>(Context, func())</code> alone, it
would be unclear what is meant by “cancel function”.</p>
<p>Don’t use named result parameters when the names produce
<a href="#repetitive-with-type">unnecessary repetition</a>.</p>
<pre><code class="language-go">// Bad:
func (n *Node) Parent1() (node *Node)
func (n *Node) Parent2() (node *Node, err error)
</code></pre>
<p>Don’t name result parameters in order to avoid declaring a variable inside the
function. This practice results in unnecessary API verbosity at the cost of
minor implementation brevity.</p>
<p><a href="https://tour.golang.org/basics/7">Naked returns</a> are acceptable only in a small function. Once it’s a
medium-sized function, be explicit with your returned values. Similarly, do not
name result parameters just because it enables you to use naked returns.
<a href="guide#clarity">Clarity</a> is always more important than saving a few lines in
your function.</p>
<p>It is always acceptable to name a result parameter if its value must be changed
in a deferred closure.</p>
<blockquote>
<p><strong>Tip:</strong> Types can often be clearer than names in function signatures.
<a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #38: Functions as Named Types</a> demonstrates this.</p>
<p>In, [<code>WithTimeout</code>] above, the real code uses a [<code>CancelFunc</code>] instead of a
raw <code>func()</code> in the result parameter list and requires little effort to
document.</p>
</blockquote>
<p><a id="package-comments"></a></p>
<h3 id="package-comments">Package comments<a class="headerlink" href="#package-comments" title="Permanent link">¶</a></h3>
<p><a id="TOC-PackageComments"></a></p>
<p>Package comments must appear immediately above the package clause with no blank
line between the comment and the package name. Example:</p>
<pre><code class="language-go">// Good:
// Package math provides basic constants and mathematical functions.
//
// This package does not guarantee bit-identical results across architectures.
package math
</code></pre>
<p>There must be a single package comment per package. If a package is composed of
multiple files, exactly one of the files should have a package comment.</p>
<p>Comments for <code>main</code> packages have a slightly different form, where the name of
the <code>go_binary</code> rule in the BUILD file takes the place of the package name.</p>
<pre><code class="language-go">// Good:
// The seed_generator command is a utility that generates a Finch seed file
// from a set of JSON study configs.
package main
</code></pre>
<p>Other styles of comment are fine as long as the name of the binary is exactly as
written in the BUILD file. When the binary name is the first word, capitalizing
it is required even though it does not strictly match the spelling of the
command-line invocation.</p>
<pre><code class="language-go">// Good:
// Binary seed_generator ...
// Command seed_generator ...
// Program seed_generator ...
// The seed_generator command ...
// The seed_generator program ...
// Seed_generator ...
</code></pre>
<p>Tips:</p>
<ul>
<li>
<p>Example command-line invocations and API usage can be useful documentation.
    For Godoc formatting, indent the comment lines containing code.</p>
</li>
<li>
<p>If there is no obvious primary file or if the package comment is
    extraordinarily long, it is acceptable to put the doc comment in a file
    named <code>doc.go</code> with only the comment and the package clause.</p>
</li>
<li>
<p>Multiline comments can be used instead of multiple single-line comments.
    This is primarily useful if the documentation contains sections which may be
    useful to copy and paste from the source file, as with sample command-lines
    (for binaries) and template examples.</p>
<p>```go
// Good:
/*
The seed_generator command is a utility that generates a Finch seed file
from a set of JSON study configs.</p>
<pre><code>seed_generator *.json | base64 &gt; finch-seed.base64
</code></pre>
<p>*/
package template
```</p>
</li>
<li>
<p>Comments intended for maintainers and that apply to the whole file are
    typically placed after import declarations. These are not surfaced in Godoc
    and are not subject to the rules above on package comments.</p>
</li>
</ul>
<p><a id="imports"></a></p>
<h2 id="imports">Imports<a class="headerlink" href="#imports" title="Permanent link">¶</a></h2>
<p><a id="TOC-Imports"></a></p>
<p><a id="import-renaming"></a></p>
<h3 id="import-renaming">Import renaming<a class="headerlink" href="#import-renaming" title="Permanent link">¶</a></h3>
<p>Imports should only be renamed to avoid a name collision with other imports. (A
corollary of this is that <a href="#package-names">good package names</a> should not
require renaming.) In the event of a name collision, prefer to rename the most
local or project-specific import. Local names (aliases) for packages must follow
<a href="#package-names">the guidance around package naming</a>, including the prohibition
on the use of underscores and capital letters.</p>
<p>Generated protocol buffer packages must be renamed to remove underscores from
their names, and their aliases must have a <code>pb</code> suffix. See
<a href="best-practices#import-protos">proto and stub best practices</a> for more information.</p>
<pre><code class="language-go">// Good:
import (
    fspb "path/to/package/foo_service_go_proto"
)
</code></pre>
<p>Imports that have package names with no useful identifying information (e.g.
<code>package v1</code>) should be renamed to include the previous path component. The
rename must be consistent with other local files importing the same package and
may include the version number.</p>
<p><strong>Note:</strong> It is preferred to rename the package to conform with
<a href="#package-names">good package names</a>, but that is often not feasible for
packages in vendored directories.</p>
<pre><code class="language-go">// Good:
import (
    core "github.com/kubernetes/api/core/v1"
    meta "github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1"
)
</code></pre>
<p>If you need to import a package whose name collides with a common local variable
name that you want to use (e.g. <code>url</code>, <code>ssh</code>) and you wish to rename the
package, the preferred way to do so is with the <code>pkg</code> suffix (e.g. <code>urlpkg</code>).
Note that it is possible to shadow a package with a local variable; this rename
is only necessary if the package still needs to be used when such a variable is
in scope.</p>
<p><a id="import-grouping"></a></p>
<h3 id="import-grouping">Import grouping<a class="headerlink" href="#import-grouping" title="Permanent link">¶</a></h3>
<p>Imports should be organized in two groups:</p>
<ul>
<li>
<p>Standard library packages</p>
</li>
<li>
<p>Other (project and vendored) packages</p>
</li>
</ul>
<pre><code class="language-go">// Good:
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"
    foopb "myproj/foo/proto/proto"
    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
</code></pre>
<p>It is acceptable to split the project packages into multiple groups, for example
if you want a separate group for renamed, imported-only-for-side-effects or
another special group of imports.</p>
<pre><code class="language-go">// Good:
package main

import (
    "fmt"
    "hash/adler32"
    "os"


    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"

    foopb "myproj/foo/proto/proto"

    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
</code></pre>
<p><strong>Note:</strong> Maintaining optional groups - splitting beyond what is necessary for
the mandatory separation between standard library and Google imports - is not
supported by the <a href="golang.org/x/tools/cmd/goimports">goimports</a> tool. Additional import subgroups require attention
on the part of both authors and reviewers to maintain in a conforming state.</p>
<p>Google programs that are also AppEngine apps should have a separate group for
AppEngine imports.</p>
<p>Gofmt takes care of sorting each group by import path. However, it does not
automatically separate imports into groups. The popular <a href="golang.org/x/tools/cmd/goimports">goimports</a> tool
combines Gofmt and import management, separating imports into groups based on
the decision above. It is permissible to let <a href="golang.org/x/tools/cmd/goimports">goimports</a> manage import
arrangement entirely, but as a file is revised its import list must remain
internally consistent.</p>
<p><a id="import-blank"></a></p>
<h3 id="import-blank-import-_">Import “blank” (<code>import _</code>)<a class="headerlink" href="#import-blank-import-_" title="Permanent link">¶</a></h3>
<p><a id="TOC-ImportBlank"></a></p>
<p>Packages that are imported only for their side effects (using the syntax <code>import
_ "package"</code>) may only be imported in a main package, or in tests that require
them.</p>
<p>Some examples of such packages include:</p>
<ul>
<li>
<p><a href="https://pkg.go.dev/time/tzdata">time/tzdata</a></p>
</li>
<li>
<p><a href="https://pkg.go.dev/image/jpeg">image/jpeg</a> in image processing code</p>
</li>
</ul>
<p>Avoid blank imports in library packages, even if the library indirectly depends
on them. Constraining side-effect imports to the main package helps control
dependencies, and makes it possible to write tests that rely on a different
import without conflict or wasted build costs.</p>
<p>The following are the only exceptions to this rule:</p>
<ul>
<li>
<p>You may use a blank import to bypass the check for disallowed imports in the
    <a href="https://github.com/bazelbuild/rules_go/blob/master/go/nogo.rst">nogo static checker</a>.</p>
</li>
<li>
<p>You may use a blank import of the <a href="https://pkg.go.dev/embed">embed</a> package
    in a source file which uses the <code>//go:embed</code> compiler directive.</p>
</li>
</ul>
<p><strong>Tip:</strong> If you create a library package that indirectly depends on a
side-effect import in production, document the intended usage.</p>
<p><a id="import-dot"></a></p>
<h3 id="import-dot-import">Import “dot” (<code>import .</code>)<a class="headerlink" href="#import-dot-import" title="Permanent link">¶</a></h3>
<p><a id="TOC-ImportDot"></a></p>
<p>The <code>import .</code> form is a language feature that allows bringing identifiers
exported from another package to the current package without qualification. See
the <a href="https://go.dev/ref/spec#Import_declarations">language spec</a> for more.</p>
<p>Do <strong>not</strong> use this feature in the Google codebase; it makes it harder to tell
where the functionality is coming from.</p>
<pre><code class="language-go">// Bad:
package foo_test

import (
    "bar/testutil" // also imports "foo"
    . "foo"
)

var myThing = Bar() // Bar defined in package foo; no qualification needed.
</code></pre>
<pre><code class="language-go">// Good:
package foo_test

import (
    "bar/testutil" // also imports "foo"
    "foo"
)

var myThing = foo.Bar()
</code></pre>
<p><a id="errors"></a></p>
<h2 id="errors">Errors<a class="headerlink" href="#errors" title="Permanent link">¶</a></h2>
<p><a id="returning-errors"></a></p>
<h3 id="returning-errors">Returning errors<a class="headerlink" href="#returning-errors" title="Permanent link">¶</a></h3>
<p><a id="TOC-ReturningErrors"></a></p>
<p>Use <code>error</code> to signal that a function can fail. By convention, <code>error</code> is the
last result parameter.</p>
<pre><code class="language-go">// Good:
func Good() error { /* ... */ }
</code></pre>
<p>Returning a <code>nil</code> error is the idiomatic way to signal a successful operation
that could otherwise fail. If a function returns an error, callers must treat
all non-error return values as unspecified unless explicitly documented
otherwise. Commonly, the non-error return values are their zero values, but this
cannot be assumed.</p>
<pre><code class="language-go">// Good:
func GoodLookup() (*Result, error) {
    // ...
    if err != nil {
        return nil, err
    }
    return res, nil
}
</code></pre>
<p>Exported functions that return errors should return them using the <code>error</code> type.
Concrete error types are susceptible to subtle bugs: a concrete <code>nil</code> pointer
can get wrapped into an interface and thus become a non-nil value (see the
<a href="https://golang.org/doc/faq#nil_error">Go FAQ entry on the topic</a>).</p>
<pre><code class="language-go">// Bad:
func Bad() *os.PathError { /*...*/ }
</code></pre>
<p><strong>Tip</strong>: A function that takes a <code>context.Context</code> argument should usually
return an <code>error</code> so that the caller can determine if the context was cancelled
while the function was running.</p>
<p><a id="error-strings"></a></p>
<h3 id="error-strings">Error strings<a class="headerlink" href="#error-strings" title="Permanent link">¶</a></h3>
<p><a id="TOC-ErrorStrings"></a></p>
<p>Error strings should not be capitalized (unless beginning with an exported name,
a proper noun or an acronym) and should not end with punctuation. This is
because error strings usually appear within other context before being printed
to the user.</p>
<pre><code class="language-go">// Bad:
err := fmt.Errorf("Something bad happened.")
</code></pre>
<pre><code class="language-go">// Good:
err := fmt.Errorf("something bad happened")
</code></pre>
<p>On the other hand, the style for the full displayed message (logging, test
failure, API response, or other UI) depends, but should typically be
capitalized.</p>
<pre><code class="language-go">// Good:
log.Infof("Operation aborted: %v", err)
log.Errorf("Operation aborted: %v", err)
t.Errorf("Op(%q) failed unexpectedly; err=%v", args, err)
</code></pre>
<p><a id="handle-errors"></a></p>
<h3 id="handle-errors">Handle errors<a class="headerlink" href="#handle-errors" title="Permanent link">¶</a></h3>
<p><a id="TOC-HandleErrors"></a></p>
<p>Code that encounters an error should make a deliberate choice about how to
handle it. It is not usually appropriate to discard errors using <code>_</code> variables.
If a function returns an error, do one of the following:</p>
<ul>
<li>Handle and address the error immediately.</li>
<li>Return the error to the caller.</li>
<li>In exceptional situations, call [<code>log.Fatal</code>] or (if absolutely necessary)
    <code>panic</code>.</li>
</ul>
<p><strong>Note:</strong> <code>log.Fatalf</code> is not the standard library log. See [#logging].</p>
<p>In the rare circumstance where it is appropriate to ignore or discard an error
(for example a call to [<code>(*bytes.Buffer).Write</code>] that is documented to never
fail), an accompanying comment should explain why this is safe.</p>
<pre><code class="language-go">// Good:
var b *bytes.Buffer

n, _ := b.Write(p) // never returns a non-nil error
</code></pre>
<p>For more discussion and examples of error handling, see
<a href="http://golang.org/doc/effective_go.html#errors">Effective Go</a> and
<a href="../best-practices/#error-handling">best practices</a>.</p>
<p><a id="in-band-errors"></a></p>
<h3 id="in-band-errors">In-band errors<a class="headerlink" href="#in-band-errors" title="Permanent link">¶</a></h3>
<p><a id="TOC-In-Band-Errors"></a></p>
<p>In C and similar languages, it is common for functions to return values like -1,
null, or the empty string to signal errors or missing results. This is known as
in-band error handling.</p>
<pre><code class="language-go">// Bad:
// Lookup returns the value for key or -1 if there is no mapping for key.
func Lookup(key string) int
</code></pre>
<p>Failing to check for an in-band error value can lead to bugs and can attribute
errors to the wrong function.</p>
<pre><code class="language-go">// Bad:
// The following line returns an error that Parse failed for the input value,
// whereas the failure was that there is no mapping for missingKey.
return Parse(Lookup(missingKey))
</code></pre>
<p>Go’s support for multiple return values provides a better solution (see the
<a href="http://golang.org/doc/effective_go.html#multiple-returns">Effective Go section on multiple returns</a>). Instead of requiring clients to
check for an in-band error value, a function should return an additional value
to indicate whether its other return values are valid. This return value may be
an error or a boolean when no explanation is needed, and should be the final
return value.</p>
<pre><code class="language-go">// Good:
// Lookup returns the value for key or ok=false if there is no mapping for key.
func Lookup(key string) (value string, ok bool)
</code></pre>
<p>This API prevents the caller from incorrectly writing <code>Parse(Lookup(key))</code> which
causes a compile-time error, since <code>Lookup(key)</code> has 2 outputs.</p>
<p>Returning errors in this way encourages more robust and explicit error handling:</p>
<pre><code class="language-go">// Good:
value, ok := Lookup(key)
if !ok {
    return fmt.Errorf("no value for %q", key)
}
return Parse(value)
</code></pre>
<p>Some standard library functions, like those in package <code>strings</code>, return in-band
error values. This greatly simplifies string-manipulation code at the cost of
requiring more diligence from the programmer. In general, Go code in the Google
codebase should return additional values for errors.</p>
<p><a id="indent-error-flow"></a></p>
<h3 id="indent-error-flow">Indent error flow<a class="headerlink" href="#indent-error-flow" title="Permanent link">¶</a></h3>
<p><a id="TOC-IndentErrorFlow"></a></p>
<p>Handle errors before proceeding with the rest of your code. This improves the
readability of the code by enabling the reader to find the normal path quickly.
This same logic applies to any block which tests a condition then ends in a
terminal condition (e.g., <code>return</code>, <code>panic</code>, <code>log.Fatal</code>).</p>
<p>Code that runs if the terminal condition is not met should appear after the <code>if</code>
block, and should not be indented in an <code>else</code> clause.</p>
<pre><code class="language-go">// Good:
if err != nil {
    // error handling
    return // or continue, etc.
}
// normal code
</code></pre>
<pre><code class="language-go">// Bad:
if err != nil {
    // error handling
} else {
    // normal code that looks abnormal due to indentation
}
</code></pre>
<blockquote>
<p><strong>Tip:</strong> If you are using a variable for more than a few lines of code, it is
generally not worth using the <code>if</code>-with-initializer style. In these cases, it
is usually better to move the declaration out and use a standard <code>if</code>
statement:</p>
<p><code>go
// Good:
x, err := f()
if err != nil {
  // error handling
  return
}
// lots of code that uses x
// across multiple lines</code></p>
<p><code>go
// Bad:
if x, err := f(); err != nil {
  // error handling
  return
} else {
  // lots of code that uses x
  // across multiple lines
}</code></p>
</blockquote>
<p>See <a href="https://google.github.io/styleguide/go/index.html#gotip">Go Tip #1: Line of Sight</a> and
<a href="https://testing.googleblog.com/2017/06/code-health-reduce-nesting-reduce.html">TotT: Reduce Code Complexity by Reducing Nesting</a>
for more details.</p>
<p><a id="language"></a></p>
<h2 id="language">Language<a class="headerlink" href="#language" title="Permanent link">¶</a></h2>
<p><a id="literal-formatting"></a></p>
<h3 id="literal-formatting">Literal formatting<a class="headerlink" href="#literal-formatting" title="Permanent link">¶</a></h3>
<p>Go has an exceptionally powerful <a href="https://golang.org/ref/spec#Composite_literals">composite literal syntax</a>, with which it is
possible to express deeply-nested, complicated values in a single expression.
Where possible, this literal syntax should be used instead of building values
field-by-field. The <code>gofmt</code> formatting for literals is generally quite good, but
there are some additional rules for keeping these literals readable and
maintainable.</p>
<p><a id="literal-field-names"></a></p>
<h4 id="field-names">Field names<a class="headerlink" href="#field-names" title="Permanent link">¶</a></h4>
<p>Struct literals should usually specify <strong>field names</strong> for types defined outside
the current package.</p>
<ul>
<li>
<p>Include field names for types from other packages.</p>
<p><code>go
// Good:
good := otherpkg.Type{A: 42}</code></p>
<p>The position of fields in a struct and the full set of fields (both of which
are necessary to get right when field names are omitted) are not usually
considered to be part of a struct’s public API; specifying the field name is
needed to avoid unnecessary coupling.</p>
<p><code>go
// Bad:
// https://pkg.go.dev/encoding/csv#Reader
r := csv.Reader{',', '#', 4, false, false, false, false}</code></p>
<p>Field names may be omitted within small, simple structs whose composition
and order are documented as being stable.</p>
<p><code>go
// Good:
okay := image.Point{42, 54}
also := image.Point{X: 42, Y: 54}</code></p>
</li>
<li>
<p>For package-local types, field names are optional.</p>
<p><code>go
// Good:
okay := Type{42}
also := internalType{4, 2}</code></p>
<p>Field names should still be used if it makes the code clearer, and it is
very common to do so. For example, a struct with a large number of fields
should almost always be initialized with field names.</p>
<!-- TODO: Maybe a better example here that doesn't have many fields. -->
<p><code>go
// Good:
okay := StructWithLotsOfFields{
  field1: 1,
  field2: "two",
  field3: 3.14,
  field4: true,
}</code></p>
</li>
</ul>
<p><a id="literal-matching-braces"></a></p>
<h4 id="matching-braces">Matching braces<a class="headerlink" href="#matching-braces" title="Permanent link">¶</a></h4>
<p>The closing half of a brace pair should always appear on a line with the same
amount of indentation as the opening brace. One-line literals necessarily have
this property. When the literal spans multiple lines, maintaining this property
keeps the brace matching for literals the same as brace matching for common Go
syntactic constructs like functions and <code>if</code> statements.</p>
<p>The most common mistake in this area is putting the closing brace on the same
line as a value in a multi-line struct literal. In these cases, the line should
end with a comma and the closing brace should appear on the next line.</p>
<pre><code class="language-go">// Good:
good := []*Type{{Key: "value"}}
</code></pre>
<pre><code class="language-go">// Good:
good := []*Type{
    {Key: "multi"},
    {Key: "line"},
}
</code></pre>
<pre><code class="language-go">// Bad:
bad := []*Type{
    {Key: "multi"},
    {Key: "line"}}
</code></pre>
<pre><code class="language-go">// Bad:
bad := []*Type{
    {
        Key: "value"},
}
</code></pre>
<p><a id="literal-cuddled-braces"></a></p>
<h4 id="cuddled-braces">Cuddled braces<a class="headerlink" href="#cuddled-braces" title="Permanent link">¶</a></h4>
<p>Dropping whitespace between braces (aka “cuddling” them) for slice and array
literals is only permitted when both of the following are true.</p>
<ul>
<li>The <a href="#literal-matching-braces">indentation matches</a></li>
<li>The inner values are also literals or proto builders (i.e. not a variable or
    other expression)</li>
</ul>
<pre><code class="language-go">// Good:
good := []*Type{
    { // Not cuddled
        Field: "value",
    },
    {
        Field: "value",
    },
}
</code></pre>
<pre><code class="language-go">// Good:
good := []*Type{{ // Cuddled correctly
    Field: "value",
}, {
    Field: "value",
}}
</code></pre>
<pre><code class="language-go">// Good:
good := []*Type{
    first, // Can't be cuddled
    {Field: "second"},
}
</code></pre>
<pre><code class="language-go">// Good:
okay := []*pb.Type{pb.Type_builder{
    Field: "first", // Proto Builders may be cuddled to save vertical space
}.Build(), pb.Type_builder{
    Field: "second",
}.Build()}
</code></pre>
<pre><code class="language-go">// Bad:
bad := []*Type{
    first,
    {
        Field: "second",
    }}
</code></pre>
<p><a id="literal-repeated-type-names"></a></p>
<h4 id="repeated-type-names">Repeated type names<a class="headerlink" href="#repeated-type-names" title="Permanent link">¶</a></h4>
<p>Repeated type names may be omitted from slice and map literals. This can be
helpful in reducing clutter. A reasonable occasion for repeating the type names
explicitly is when dealing with a complex type that is not common in your
project, when the repetitive type names are on lines that are far apart and can
remind the reader of the context.</p>
<pre><code class="language-go">// Good:
good := []*Type{
    {A: 42},
    {A: 43},
}
</code></pre>
<pre><code class="language-go">// Bad:
repetitive := []*Type{
    &amp;Type{A: 42},
    &amp;Type{A: 43},
}
</code></pre>
<pre><code class="language-go">// Good:
good := map[Type1]*Type2{
    {A: 1}: {B: 2},
    {A: 3}: {B: 4},
}
</code></pre>
<pre><code class="language-go">// Bad:
repetitive := map[Type1]*Type2{
    Type1{A: 1}: &amp;Type2{B: 2},
    Type1{A: 3}: &amp;Type2{B: 4},
}
</code></pre>
<p><strong>Tip:</strong> If you want to remove repetitive type names in struct literals, you can
run <code>gofmt -s</code>.</p>
<p><a id="literal-zero-value-fields"></a></p>
<h4 id="zero-value-fields">Zero-value fields<a class="headerlink" href="#zero-value-fields" title="Permanent link">¶</a></h4>
<p><a href="https://golang.org/ref/spec#The_zero_value">Zero-value</a> fields may be omitted from struct literals when clarity is not lost
as a result.</p>
<p>Well-designed APIs often employ zero-value construction for enhanced
readability. For example, omitting the three zero-value fields from the
following struct draws attention to the only option that is being specified.</p>
<pre><code class="language-go">// Bad:
import (
  "github.com/golang/leveldb"
  "github.com/golang/leveldb/db"
)

ldb := leveldb.Open("/my/table", &amp;db.Options{
    BlockSize: 1&lt;&lt;16,
    ErrorIfDBExists: true,

    // These fields all have their zero values.
    BlockRestartInterval: 0,
    Comparer: nil,
    Compression: nil,
    FileSystem: nil,
    FilterPolicy: nil,
    MaxOpenFiles: 0,
    WriteBufferSize: 0,
    VerifyChecksums: false,
})
</code></pre>
<pre><code class="language-go">// Good:
import (
  "github.com/golang/leveldb"
  "github.com/golang/leveldb/db"
)

ldb := leveldb.Open("/my/table", &amp;db.Options{
    BlockSize: 1&lt;&lt;16,
    ErrorIfDBExists: true,
})
</code></pre>
<p>Structs within table-driven tests often benefit from <a href="#literal-field-names">explicit field names</a>,
especially when the test struct is not trivial. This allows the author to omit
the zero-valued fields entirely when the fields in question are not related to
the test case. For example, successful test cases should omit any error-related
or failure-related fields. In cases where the zero value is necessary to
understand the test case, such as testing for zero or <code>nil</code> inputs, the field
names should be specified.</p>
<p><strong>Concise</strong></p>
<pre><code class="language-go">tests := []struct {
    input      string
    wantPieces []string
    wantErr    error
}{
    {
        input:      "1.2.3.4",
        wantPieces: []string{"1", "2", "3", "4"},
    },
    {
        input:   "hostname",
        wantErr: ErrBadHostname,
    },
}
</code></pre>
<p><strong>Explicit</strong></p>
<pre><code class="language-go">tests := []struct {
    input    string
    wantIPv4 bool
    wantIPv6 bool
    wantErr  bool
}{
    {
        input:    "1.2.3.4",
        wantIPv4: true,
        wantIPv6: false,
    },
    {
        input:    "1:2::3:4",
        wantIPv4: false,
        wantIPv6: true,
    },
    {
        input:    "hostname",
        wantIPv4: false,
        wantIPv6: false,
        wantErr:  true,
    },
}
</code></pre>
<p><a id="nil-slices"></a></p>
<h3 id="nil-slices">Nil slices<a class="headerlink" href="#nil-slices" title="Permanent link">¶</a></h3>
<p>For most purposes, there is no functional difference between <code>nil</code> and the empty
slice. Built-in functions like <code>len</code> and <code>cap</code> behave as expected on <code>nil</code>
slices.</p>
<pre><code class="language-go">// Good:
import "fmt"

var s []int         // nil

fmt.Println(s)      // []
fmt.Println(len(s)) // 0
fmt.Println(cap(s)) // 0
for range s {...}   // no-op

s = append(s, 42)
fmt.Println(s)      // [42]
</code></pre>
<p>If you declare an empty slice as a local variable (especially if it can be the
source of a return value), prefer the nil initialization to reduce the risk of
bugs by callers.</p>
<pre><code class="language-go">// Good:
var t []string
</code></pre>
<pre><code class="language-go">// Bad:
t := []string{}
</code></pre>
<p>Do not create APIs that force their clients to make distinctions between nil and
the empty slice.</p>
<pre><code class="language-go">// Good:
// Ping pings its targets.
// Returns hosts that successfully responded.
func Ping(hosts []string) ([]string, error) { ... }
</code></pre>
<pre><code class="language-go">// Bad:
// Ping pings its targets and returns a list of hosts
// that successfully responded. Can be empty if the input was empty.
// nil signifies that a system error occurred.
func Ping(hosts []string) []string { ... }
</code></pre>
<p>When designing interfaces, avoid making a distinction between a <code>nil</code> slice and
a non-<code>nil</code>, zero-length slice, as this can lead to subtle programming errors.
This is typically accomplished by using <code>len</code> to check for emptiness, rather
than <code>== nil</code>.</p>
<p>This implementation accepts both <code>nil</code> and zero-length slices as “empty”:</p>
<pre><code class="language-go">// Good:
// describeInts describes s with the given prefix, unless s is empty.
func describeInts(prefix string, s []int) {
    if len(s) == 0 {
        return
    }
    fmt.Println(prefix, s)
}
</code></pre>
<p>Instead of relying on the distinction as a part of the API:</p>
<pre><code class="language-go">// Bad:
func maybeInts() []int { /* ... */ }

// describeInts describes s with the given prefix; pass nil to skip completely.
func describeInts(prefix string, s []int) {
  // The behavior of this function unintentionally changes depending on what
  // maybeInts() returns in 'empty' cases (nil or []int{}).
  if s == nil {
    return
  }
  fmt.Println(prefix, s)
}

describeInts("Here are some ints:", maybeInts())
</code></pre>
<p>See <a href="#in-band-errors">in-band errors</a> for further discussion.</p>
<p><a id="indentation-confusion"></a></p>
<h3 id="indentation-confusion">Indentation confusion<a class="headerlink" href="#indentation-confusion" title="Permanent link">¶</a></h3>
<p>Avoid introducing a line break if it would align the rest of the line with an
indented code block. If this is unavoidable, leave a space to separate the code
in the block from the wrapped line.</p>
<pre><code class="language-go">// Bad:
if longCondition1 &amp;&amp; longCondition2 &amp;&amp;
    // Conditions 3 and 4 have the same indentation as the code within the if.
    longCondition3 &amp;&amp; longCondition4 {
    log.Info("all conditions met")
}
</code></pre>
<p>See the following sections for specific guidelines and examples:</p>
<ul>
<li><a href="#func-formatting">Function formatting</a></li>
<li><a href="#conditional-formatting">Conditionals and loops</a></li>
<li><a href="#literal-formatting">Literal formatting</a></li>
</ul>
<p><a id="func-formatting"></a></p>
<h3 id="function-formatting">Function formatting<a class="headerlink" href="#function-formatting" title="Permanent link">¶</a></h3>
<p>The signature of a function or method declaration should remain on a single line
to avoid <a href="#indentation-confusion">indentation confusion</a>.</p>
<p>Function argument lists can make some of the longest lines in a Go source file.
However, they precede a change in indentation, and therefore it is difficult to
break the line in a way that does not make subsequent lines look like part of
the function body in a confusing way:</p>
<pre><code class="language-go">// Bad:
func (r *SomeType) SomeLongFunctionName(foo1, foo2, foo3 string,
    foo4, foo5, foo6 int) {
    foo7 := bar(foo1)
    // ...
}
</code></pre>
<p>See <a href="best-practices#funcargs">best practices</a> for a few options for shortening
the call sites of functions that would otherwise have many arguments.</p>
<pre><code class="language-go">// Good:
good := foo.Call(long, CallOptions{
    Names:   list,
    Of:      of,
    The:     parameters,
    Func:    all,
    Args:    on,
    Now:     separate,
    Visible: lines,
})
</code></pre>
<pre><code class="language-go">// Bad:
bad := foo.Call(
    long,
    list,
    of,
    parameters,
    all,
    on,
    separate,
    lines,
)
</code></pre>
<p>Lines can often be shortened by factoring out local variables.</p>
<pre><code class="language-go">// Good:
local := helper(some, parameters, here)
good := foo.Call(list, of, parameters, local)
</code></pre>
<p>Similarly, function and method calls should not be separated based solely on
line length.</p>
<pre><code class="language-go">// Good:
good := foo.Call(long, list, of, parameters, all, on, one, line)
</code></pre>
<pre><code class="language-go">// Bad:
bad := foo.Call(long, list, of, parameters,
    with, arbitrary, line, breaks)
</code></pre>
<p>Do not add comments to specific function parameters. Instead, use an
<a href="best-practices#option-structure">option struct</a> or add more detail to the
function documentation.</p>
<pre><code class="language-go">// Good:
good := server.New(ctx, server.Options{Port: 42})
</code></pre>
<pre><code class="language-go">// Bad:
bad := server.New(
    ctx,
    42, // Port
)
</code></pre>
<p>If call-sites are uncomfortably long, consider refactoring:</p>
<pre><code class="language-go">// Good:
// Sometimes variadic arguments can be factored out
replacements := []string{
    "from", "to", // related values can be formatted adjacent to one another
    "source", "dest",
    "original", "new",
}

// Use the replacement struct as inputs to NewReplacer.
replacer := strings.NewReplacer(replacements...)
</code></pre>
<p>If the API cannot be changed or if the local call is unusual (whether or not the
call is too long), it is always permissible to add line breaks if it aids in
understanding the call.</p>
<pre><code class="language-go">// Good:
canvas.RenderCube(cube,
    x0, y0, z0,
    x0, y0, z1,
    x0, y1, z0,
    x0, y1, z1,
    x1, y0, z0,
    x1, y0, z1,
    x1, y1, z0,
    x1, y1, z1,
)
</code></pre>
<p>Note that the lines in the above example are not wrapped at a specific column
boundary but are grouped based on co-ordinate triples.</p>
<p>Long string literals within functions should not be broken for the sake of line
length. For functions that include such strings, a line break can be added after
the string format, and the arguments can be provided on the next or subsequent
lines. The decision about where the line breaks should go is best made based on
semantic groupings of inputs, rather than based purely on line length.</p>
<pre><code class="language-go">// Good:
log.Warningf("Database key (%q, %d, %q) incompatible in transaction started by (%q, %d, %q)",
    currentCustomer, currentOffset, currentKey,
    txCustomer, txOffset, txKey)
</code></pre>
<pre><code class="language-go">// Bad:
log.Warningf("Database key (%q, %d, %q) incompatible in"+
    " transaction started by (%q, %d, %q)",
    currentCustomer, currentOffset, currentKey, txCustomer,
    txOffset, txKey)
</code></pre>
<p><a id="conditional-formatting"></a></p>
<h3 id="conditionals-and-loops">Conditionals and loops<a class="headerlink" href="#conditionals-and-loops" title="Permanent link">¶</a></h3>
<p>An <code>if</code> statement should not be line broken; multi-line <code>if</code> clauses can lead to
<a href="#indentation-confusion">indentation confusion</a>.</p>
<pre><code class="language-go">// Bad:
// The second if statement is aligned with the code within the if block, causing
// indentation confusion.
if db.CurrentStatusIs(db.InTransaction) &amp;&amp;
    db.ValuesEqual(db.TransactionKey(), row.Key()) {
    return db.Errorf(db.TransactionError, "query failed: row (%v): key does not match transaction key", row)
}
</code></pre>
<p>If the short-circuit behavior is not required, the boolean operands can be
extracted directly:</p>
<pre><code class="language-go">// Good:
inTransaction := db.CurrentStatusIs(db.InTransaction)
keysMatch := db.ValuesEqual(db.TransactionKey(), row.Key())
if inTransaction &amp;&amp; keysMatch {
    return db.Error(db.TransactionError, "query failed: row (%v): key does not match transaction key", row)
}
</code></pre>
<p>There may also be other locals that can be extracted, especially if the
conditional is already repetitive:</p>
<pre><code class="language-go">// Good:
uid := user.GetUniqueUserID()
if db.UserIsAdmin(uid) || db.UserHasPermission(uid, perms.ViewServerConfig) || db.UserHasPermission(uid, perms.CreateGroup) {
    // ...
}
</code></pre>
<pre><code class="language-go">// Bad:
if db.UserIsAdmin(user.GetUniqueUserID()) || db.UserHasPermission(user.GetUniqueUserID(), perms.ViewServerConfig) || db.UserHasPermission(user.GetUniqueUserID(), perms.CreateGroup) {
    // ...
}
</code></pre>
<p><code>if</code> statements that contain closures or multi-line struct literals should
ensure that the <a href="#literal-matching-braces">braces match</a> to avoid
<a href="#indentation-confusion">indentation confusion</a>.</p>
<pre><code class="language-go">// Good:
if err := db.RunInTransaction(func(tx *db.TX) error {
    return tx.Execute(userUpdate, x, y, z)
}); err != nil {
    return fmt.Errorf("user update failed: %s", err)
}
</code></pre>
<pre><code class="language-go">// Good:
if _, err := client.Update(ctx, &amp;upb.UserUpdateRequest{
    ID:   userID,
    User: user,
}); err != nil {
    return fmt.Errorf("user update failed: %s", err)
}
</code></pre>
<p>Similarly, don’t try inserting artificial linebreaks into <code>for</code> statements. You
can always let the line simply be long if there is no elegant way to refactor
it:</p>
<pre><code class="language-go">// Good:
for i, max := 0, collection.Size(); i &lt; max &amp;&amp; !collection.HasPendingWriters(); i++ {
    // ...
}
</code></pre>
<p>Often, though, there is:</p>
<pre><code class="language-go">// Good:
for i, max := 0, collection.Size(); i &lt; max; i++ {
    if collection.HasPendingWriters() {
        break
    }
    // ...
}
</code></pre>
<p><code>switch</code> and <code>case</code> statements should also remain on a single line.</p>
<pre><code class="language-go">// Good:
switch good := db.TransactionStatus(); good {
case db.TransactionStarting, db.TransactionActive, db.TransactionWaiting:
    // ...
case db.TransactionCommitted, db.NoTransaction:
    // ...
default:
    // ...
}
</code></pre>
<pre><code class="language-go">// Bad:
switch bad := db.TransactionStatus(); bad {
case db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting:
    // ...
case db.TransactionCommitted,
    db.NoTransaction:
    // ...
default:
    // ...
}
</code></pre>
<p>If the line is excessively long, indent all cases and separate them with a blank
line to avoid <a href="#indentation-confusion">indentation confusion</a>:</p>
<pre><code class="language-go">// Good:
switch db.TransactionStatus() {
case
    db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting,
    db.TransactionCommitted:

    // ...
case db.NoTransaction:
    // ...
default:
    // ...
}
</code></pre>
<p>In conditionals comparing a variable to a constant, place the variable value on
the left hand side of the equality operator:</p>
<pre><code class="language-go">// Good:
if result == "foo" {
  // ...
}
</code></pre>
<p>Instead of the less clear phrasing where the constant comes first
(<a href="https://en.wikipedia.org/wiki/Yoda_conditions">“Yoda style conditionals”</a>):</p>
<pre><code class="language-go">// Bad:
if "foo" == result {
  // ...
}
</code></pre>
<p><a id="copying"></a></p>
<h3 id="copying">Copying<a class="headerlink" href="#copying" title="Permanent link">¶</a></h3>
<p><a id="TOC-Copying"></a></p>
<p>To avoid unexpected aliasing and similar bugs, be careful when copying a struct
from another package. For example, synchronization objects such as <code>sync.Mutex</code>
must not be copied.</p>
<p>The <code>bytes.Buffer</code> type contains a <code>[]byte</code> slice and, as an optimization for
small strings, a small byte array to which the slice may refer. If you copy a
<code>Buffer</code>, the slice in the copy may alias the array in the original, causing
subsequent method calls to have surprising effects.</p>
<p>In general, do not copy a value of type <code>T</code> if its methods are associated with
the pointer type, <code>*T</code>.</p>
<pre><code class="language-go">// Bad:
b1 := bytes.Buffer{}
b2 := b1
</code></pre>
<p>Invoking a method that takes a value receiver can hide the copy. When you author
an API, you should generally take and return pointer types if your structs
contain fields that should not be copied.</p>
<p>These are acceptable:</p>
<pre><code class="language-go">// Good:
type Record struct {
  buf bytes.Buffer
  // other fields omitted
}

func New() *Record {...}

func (r *Record) Process(...) {...}

func Consumer(r *Record) {...}
</code></pre>
<p>But these are usually wrong:</p>
<pre><code class="language-go">// Bad:
type Record struct {
  buf bytes.Buffer
  // other fields omitted
}


func (r Record) Process(...) {...} // Makes a copy of r.buf

func Consumer(r Record) {...} // Makes a copy of r.buf
</code></pre>
<p>This guidance also applies to copying <code>sync.Mutex</code>.</p>
<p><a id="dont-panic"></a></p>
<h3 id="dont-panic">Don’t panic<a class="headerlink" href="#dont-panic" title="Permanent link">¶</a></h3>
<p><a id="TOC-Don-t-Panic"></a></p>
<p>Do not use <code>panic</code> for normal error handling. Instead, use <code>error</code> and multiple
return values. See the <a href="http://golang.org/doc/effective_go.html#errors">Effective Go section on errors</a>.</p>
<p>Within <code>package main</code> and initialization code, consider [<code>log.Exit</code>] for errors
that should terminate the program (e.g., invalid configuration), as in many of
these cases a stack trace will not help the reader. Please note that
[<code>log.Exit</code>] calls [<code>os.Exit</code>] and any deferred functions will not be run.</p>
<p>For errors that indicate “impossible” conditions, namely bugs that should always
be caught during code review and/or testing, a function may reasonably return an
error or call [<code>log.Fatal</code>].</p>
<p><strong>Note:</strong> <code>log.Fatalf</code> is not the standard library log. See [#logging].</p>
<p><a id="must-functions"></a></p>
<h3 id="must-functions">Must functions<a class="headerlink" href="#must-functions" title="Permanent link">¶</a></h3>
<p>Setup helper functions that stop the program on failure follow the naming
convention <code>MustXYZ</code> (or <code>mustXYZ</code>). In general, they should only be called
early on program startup, not on things like user input where normal Go error
handling is preferred.</p>
<p>This often comes up for functions called to initialize package-level variables
exclusively at
<a href="https://golang.org/ref/spec#Package_initialization">package initialization time</a>
(e.g. <a href="https://golang.org/pkg/text/template/#Must">template.Must</a> and
<a href="https://golang.org/pkg/regexp/#MustCompile">regexp.MustCompile</a>).</p>
<pre><code class="language-go">// Good:
func MustParse(version string) *Version {
    v, err := Parse(version)
    if err != nil {
        log.Fatalf("MustParse(%q) = _, %v", version, err)
    }
    return v
}

// Package level "constant". If we wanted to use `Parse`, we would have had to
// set the value in `init`.
var DefaultVersion = MustParse("1.2.3")
</code></pre>
<p><strong>Note:</strong> <code>log.Fatalf</code> is not the standard library log. See [#logging].</p>
<p>The same convention may be used in test helpers that only stop the current test
(using <code>t.Fatal</code>). Such helpers are often convenient in creating test values,
for example in struct fields of <a href="#table-driven-tests">table driven tests</a>, as
functions that return errors cannot be directly assigned to a struct field.</p>
<pre><code class="language-go">// Good:
func mustMarshalAny(t *testing.T, m proto.Message) *anypb.Any {
  t.Helper()
  any, err := anypb.New(m)
  if err != nil {
    t.Fatalf("MustMarshalAny(t, m) = %v; want %v", err, nil)
  }
  return any
}

func TestCreateObject(t *testing.T) {
  tests := []struct{
    desc string
    data *anypb.Any
  }{
    {
      desc: "my test case",
      // Creating values directly within table driven test cases.
      data: mustMarshalAny(t, mypb.Object{}),
    },
    // ...
  }
  // ...
}
</code></pre>
<p>In both of these cases, the value of this pattern is that the helpers can be
called in a “value” context. These helpers should not be called in places where
it’s difficult to ensure an error would be caught or in a context where an error
should be <a href="#handle-errors">checked</a> (e.g., in many request handlers). For
constant inputs, this allows tests to easily ensure that the <code>Must</code> arguments
are well-formed, and for non-constant inputs it permits tests to validate that
errors are <a href="best-practices#error-handling">properly handled or propagated</a>.</p>
<p>Where <code>Must</code> functions are used in a test, they should generally be
<a href="#mark-test-helpers">marked as a test helper</a> and call <code>t.Fatal</code> on error (see
<a href="best-practices#test-helper-error-handling">error handling in test helpers</a> for
more considerations of using that).</p>
<p>They should not be used when
<a href="best-practices#error-handling">ordinary error handling</a> is possible (including
with some refactoring):</p>
<pre><code class="language-go">// Bad:
func Version(o *servicepb.Object) (*version.Version, error) {
    // Return error instead of using Must functions.
    v := version.MustParse(o.GetVersionString())
    return dealiasVersion(v)
}
</code></pre>
<p><a id="goroutine-lifetimes"></a></p>
<h3 id="goroutine-lifetimes">Goroutine lifetimes<a class="headerlink" href="#goroutine-lifetimes" title="Permanent link">¶</a></h3>
<p><a id="TOC-GoroutineLifetimes"></a></p>
<p>When you spawn goroutines, make it clear when or whether they exit.</p>
<p>Goroutines can leak by blocking on channel sends or receives. The garbage
collector will not terminate a goroutine even if the channels it is blocked on
are unreachable.</p>
<p>Even when goroutines do not leak, leaving them in-flight when they are no longer
needed can cause other subtle and hard-to-diagnose problems. Sending on a
channel that has been closed causes a panic.</p>
<pre><code class="language-go">// Bad:
ch := make(chan int)
ch &lt;- 42
close(ch)
ch &lt;- 13 // panic
</code></pre>
<p>Modifying still-in-use inputs “after the result isn’t needed” can lead to data
races. Leaving goroutines in-flight for arbitrarily long can lead to
unpredictable memory usage.</p>
<p>Concurrent code should be written such that the goroutine lifetimes are obvious.
Typically this will mean keeping synchronization-related code constrained within
the scope of a function and factoring out the logic into
<a href="#synchronous-functions">synchronous functions</a>. If the concurrency is still not obvious, it is
important to document when and why the goroutines exit.</p>
<p>Code that follows best practices around context usage often helps make this
clear. It is conventionally managed with a <code>context.Context</code>:</p>
<pre><code class="language-go">// Good:
func (w *Worker) Run(ctx context.Context) error {
    // ...
    for item := range w.q {
        // process returns at latest when the context is cancelled.
        go process(ctx, item)
    }
    // ...
}
</code></pre>
<p>There are other variants of the above that use raw signal channels like <code>chan
struct{}</code>, synchronized variables, <a href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">condition variables</a>, and
more. The important part is that the goroutine’s end is evident for subsequent
maintainers.</p>
<p>In contrast, the following code is careless about when its spawned goroutines
finish:</p>
<pre><code class="language-go">// Bad:
func (w *Worker) Run() {
    // ...
    for item := range w.q {
        // process returns when it finishes, if ever, possibly not cleanly
        // handling a state transition or termination of the Go program itself.
        go process(item)
    }
    // ...
}
</code></pre>
<p>This code may look OK, but there are several underlying problems:</p>
<ul>
<li>
<p>The code probably has undefined behavior in production, and the program may
    not terminate cleanly, even if the operating system releases the resources.</p>
</li>
<li>
<p>The code is difficult to test meaningfully due to the code’s indeterminate
    lifecycle.</p>
</li>
<li>
<p>The code may leak resources as described above.</p>
</li>
</ul>
<p>See also:</p>
<ul>
<li><a href="https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop">Never start a goroutine without knowing how it will stop</a></li>
<li>Rethinking Classical Concurrency Patterns: <a href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">slides</a>,
    <a href="https://www.youtube.com/watch?v=5zXAHh5tJqQ">video</a></li>
<li><a href="https://changelog.com/gotime/165">When Go programs end</a></li>
</ul>
<p><a id="interfaces"></a></p>
<h3 id="interfaces">Interfaces<a class="headerlink" href="#interfaces" title="Permanent link">¶</a></h3>
<p><a id="TOC-Interfaces"></a></p>
<p>Go interfaces generally belong in the package that <em>consumes</em> values of the
interface type, not a package that <em>implements</em> the interface type. The
implementing package should return concrete (usually pointer or struct) types.
That way, new methods can be added to implementations without requiring
extensive refactoring. See <a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #49: Accept Interfaces, Return Concrete Types</a>
for more details.</p>
<p>Do not export a <a href="https://abseil.io/resources/swe-book/html/ch13.html#techniques_for_using_test_doubles">test double</a> implementation of an interface from
an API that consumes it. Instead, design the API so that it can be tested using
the <a href="https://abseil.io/resources/swe-book/html/ch12.html#test_via_public_apis">public API</a> of the <a href="best-practices#use-real-transports">real implementation</a>. See
<a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #42: Authoring a Stub for Testing</a> for more details. Even when it is not
feasible to use the real implementation, it may not be necessary to introduce an
interface fully covering all methods in the real type; the consumer can create
an interface containing only the methods it needs, as demonstrated in
<a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #78: Minimal Viable Interfaces</a>.</p>
<p>To test packages that use Stubby RPC clients, use a real client connection. If a
real server cannot be run in the test, Google’s internal practice is to obtain a
real client connection to a local <a href="https://abseil.io/resources/swe-book/html/ch13.html#basic_concepts">test double</a> using the internal rpctest
package (coming soon!).</p>
<p>Do not define interfaces before they are used (see
<a href="https://testing.googleblog.com/2017/08/code-health-eliminate-yagni-smells.html">TotT: Code Health: Eliminate YAGNI Smells</a> ). Without a realistic
example of usage, it is too difficult to see whether an interface is even
necessary, let alone what methods it should contain.</p>
<p>Do not use interface-typed parameters if the users of the package do not need to
pass different types for them.</p>
<p>Do not export interfaces that the users of the package do not need.</p>
<p><strong>TODO:</strong> Write a more in-depth doc on interfaces and link to it here.</p>
<pre><code class="language-go">// Good:
package consumer // consumer.go

type Thinger interface { Thing() bool }

func Foo(t Thinger) string { ... }
</code></pre>
<pre><code class="language-go">// Good:
package consumer // consumer_test.go

type fakeThinger struct{ ... }
func (t fakeThinger) Thing() bool { ... }
...
if Foo(fakeThinger{...}) == "x" { ... }
</code></pre>
<pre><code class="language-go">// Bad:
package producer

type Thinger interface { Thing() bool }

type defaultThinger struct{ ... }
func (t defaultThinger) Thing() bool { ... }

func NewThinger() Thinger { return defaultThinger{ ... } }
</code></pre>
<pre><code class="language-go">// Good:
package producer

type Thinger struct{ ... }
func (t Thinger) Thing() bool { ... }

func NewThinger() Thinger { return Thinger{ ... } }
</code></pre>
<p><a id="generics"></a></p>
<h3 id="generics">Generics<a class="headerlink" href="#generics" title="Permanent link">¶</a></h3>
<p>Generics (formally called “<a href="https://go.dev/design/43651-type-parameters">Type Parameters</a>”) are allowed where they fulfill
your business requirements. In many applications, a conventional approach using
existing language features (slices, maps, interfaces, and so on) works just as
well without the added complexity, so be wary of premature use. See the
discussion on <a href="guide#least-mechanism">least mechanism</a>.</p>
<p>When introducing an exported API that uses generics, make sure it is suitably
documented. It’s highly encouraged to include motivating runnable <a href="#examples">examples</a>.</p>
<p>Do not use generics just because you are implementing an algorithm or data
structure that does not care about the type of its member elements. If there is
only one type being instantiated in practice, start by making your code work on
that type without using generics at all. Adding polymorphism later will be
straightforward compared to removing abstraction that is found to be
unnecessary.</p>
<p>Do not use generics to invent domain-specific languages (DSLs). In particular,
refrain from introducing error-handling frameworks that might put a significant
burden on readers. Instead prefer established <a href="#errors">error handling</a>
practices. For testing, be especially wary of introducing
<a href="#assert">assertion libraries</a> or frameworks that result in less useful
<a href="#useful-test-failures">test failures</a>.</p>
<p>In general:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=Pa_e9EeCdy8&amp;t=1250s">Write code, don’t design types</a>. From a GopherCon talk by Robert Griesemer
    and Ian Lance Taylor.</li>
<li>If you have several types that share a useful unifying interface, consider
    modeling the solution using that interface. Generics may not be needed.</li>
<li>Otherwise, instead of relying on the <code>any</code> type and excessive
    <a href="https://tour.golang.org/methods/16">type switching</a>, consider generics.</li>
</ul>
<p>See also:</p>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=nr8EpUO9jhw">Using Generics in Go</a>, talk by Ian Lance Taylor</p>
</li>
<li>
<p><a href="https://go.dev/doc/tutorial/generics">Generics tutorial</a> on Go’s webpage</p>
</li>
</ul>
<p><a id="pass-values"></a></p>
<h3 id="pass-values">Pass values<a class="headerlink" href="#pass-values" title="Permanent link">¶</a></h3>
<p><a id="TOC-PassValues"></a></p>
<p>Do not pass pointers as function arguments just to save a few bytes. If a
function reads its argument <code>x</code> only as <code>*x</code> throughout, then the argument
shouldn’t be a pointer. Common instances of this include passing a pointer to a
string (<code>*string</code>) or a pointer to an interface value (<code>*io.Reader</code>). In both
cases, the value itself is a fixed size and can be passed directly.</p>
<p>This advice does not apply to large structs, or even small structs that may
increase in size. In particular, protocol buffer messages should generally be
handled by pointer rather than by value. The pointer type satisfies the
<code>proto.Message</code> interface (accepted by <code>proto.Marshal</code>, <code>protocmp.Transform</code>,
etc.), and protocol buffer messages can be quite large and often grow larger
over time.</p>
<p><a id="receiver-type"></a></p>
<h3 id="receiver-type">Receiver type<a class="headerlink" href="#receiver-type" title="Permanent link">¶</a></h3>
<p><a id="TOC-ReceiverType"></a></p>
<p>A <a href="https://golang.org/ref/spec#Method_declarations">method receiver</a> can be passed either as a value or a pointer, just as if it
were a regular function parameter. The choice between the two is based on which
<a href="https://golang.org/ref/spec#Method_sets">method set(s)</a> the method should be a part of.</p>
<p><strong>Correctness wins over speed or simplicity.</strong> There are cases where you must
use a pointer value. In other cases, pick pointers for large types or as
future-proofing if you don’t have a good sense of how the code will grow, and
use values for simple <a href="https://en.wikipedia.org/wiki/Passive_data_structure">plain old data</a>.</p>
<p>The list below spells out each case in further detail:</p>
<ul>
<li>
<p>If the receiver is a slice and the method doesn’t reslice or reallocate the
    slice, use a value rather than a pointer.</p>
<p>```go
// Good:
type Buffer []byte</p>
<p>func (b Buffer) Len() int { return len(b) }
```</p>
</li>
<li>
<p>If the method needs to mutate the receiver, the receiver must be a pointer.</p>
<p>```go
// Good:
type Counter int</p>
<p>func (c <em>Counter) Inc() { </em>c++ }</p>
<p>// See https://pkg.go.dev/container/heap.
type Queue []Item</p>
<p>func (q <em>Queue) Push(x Item) { </em>q = append([]Item{x}, *q…) }
```</p>
</li>
<li>
<p>If the receiver is a struct containing fields that
    <a href="#copying">cannot safely be copied</a>, use a pointer receiver. Common examples
    are [<code>sync.Mutex</code>] and other synchronization types.</p>
<p>```go
// Good:
type Counter struct {
    mu    sync.Mutex
    total int
}</p>
<p>func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.total++
}
```</p>
<p><strong>Tip:</strong> Check the type’s <a href="https://pkg.go.dev/time#example-Duration">Godoc</a> for information about whether it is safe
or unsafe to copy.</p>
</li>
<li>
<p>If the receiver is a “large” struct or array, a pointer receiver may be more
    efficient. Passing a struct is equivalent to passing all of its fields or
    elements as arguments to the method. If that seems too large to
    <a href="#pass-values">pass by value</a>, a pointer is a good choice.</p>
</li>
<li>
<p>For methods that will call or run concurrently with other functions that
    modify the receiver, use a value if those modifications should not be
    visible to your method; otherwise use a pointer.</p>
</li>
<li>
<p>If the receiver is a struct or array, any of whose elements is a pointer to
    something that may be mutated, prefer a pointer receiver to make the
    intention of mutability clear to the reader.</p>
<p>```go
// Good:
type Counter struct {
    m *Metric
}</p>
<p>func (c *Counter) Inc() {
    c.m.Add(1)
}
```</p>
</li>
<li>
<p>If the receiver is a <a href="https://pkg.go.dev/builtin">built-in type</a>, such as an integer or a string, that
    does not need to be modified, use a value.</p>
<p>```go
// Good:
type User string</p>
<p>func (u User) String() { return string(u) }
```</p>
</li>
<li>
<p>If the receiver is a map, function, or channel, use a value rather than a
    pointer.</p>
<p>```go
// Good:
// See https://pkg.go.dev/net/http#Header.
type Header map[string][]string</p>
<p>func (h Header) Add(key, value string) { /<em> omitted </em>/ }
```</p>
</li>
<li>
<p>If the receiver is a “small” array or struct that is naturally a value type
    with no mutable fields and no pointers, a value receiver is usually the
    right choice.</p>
<p>```go
// Good:
// See https://pkg.go.dev/time#Time.
type Time struct { /<em> omitted </em>/ }</p>
<p>func (t Time) Add(d Duration) Time { /<em> omitted </em>/ }
```</p>
</li>
<li>
<p>When in doubt, use a pointer receiver.</p>
</li>
</ul>
<p>As a general guideline, prefer to make the methods for a type either all pointer
methods or all value methods.</p>
<p><strong>Note:</strong> There is a lot of misinformation about whether passing a value or a
pointer to a function can affect performance. The compiler can choose to pass
pointers to values on the stack as well as copying values on the stack, but
these considerations should not outweigh the readability and correctness of the
code in most circumstances. When the performance does matter, it is important to
profile both approaches with a realistic benchmark before deciding that one
approach outperforms the other.</p>
<p><a id="switch-break"></a></p>
<h3 id="switch-and-break"><code>switch</code> and <code>break</code><a class="headerlink" href="#switch-and-break" title="Permanent link">¶</a></h3>
<p><a id="TOC-SwitchBreak"></a></p>
<p>Do not use <code>break</code> statements without target labels at the ends of <code>switch</code>
clauses; they are redundant. Unlike in C and Java, <code>switch</code> clauses in Go
automatically break, and a <code>fallthrough</code> statement is needed to achieve the
C-style behavior. Use a comment rather than <code>break</code> if you want to clarify the
purpose of an empty clause.</p>
<pre><code class="language-go">// Good:
switch x {
case "A", "B":
    buf.WriteString(x)
case "C":
    // handled outside of the switch statement
default:
    return fmt.Errorf("unknown value: %q", x)
}
</code></pre>
<pre><code class="language-go">// Bad:
switch x {
case "A", "B":
    buf.WriteString(x)
    break // this break is redundant
case "C":
    break // this break is redundant
default:
    return fmt.Errorf("unknown value: %q", x)
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> If a <code>switch</code> clause is within a <code>for</code> loop, using <code>break</code> within
<code>switch</code> does not exit the enclosing <code>for</code> loop.</p>
<p><code>go
for {
  switch x {
  case "A":
     break // exits the switch, not the loop
  }
}</code></p>
<p>To escape the enclosing loop, use a label on the <code>for</code> statement:</p>
<p><code>go
loop:
  for {
    switch x {
    case "A":
       break loop // exits the loop
    }
  }</code></p>
</blockquote>
<p><a id="synchronous-functions"></a></p>
<h3 id="synchronous-functions">Synchronous functions<a class="headerlink" href="#synchronous-functions" title="Permanent link">¶</a></h3>
<p><a id="TOC-SynchronousFunctions"></a></p>
<p>Synchronous functions return their results directly and finish any callbacks or
channel operations before returning. Prefer synchronous functions over
asynchronous functions.</p>
<p>Synchronous functions keep goroutines localized within a call. This helps to
reason about their lifetimes, and avoid leaks and data races. Synchronous
functions are also easier to test, since the caller can pass an input and check
the output without the need for polling or synchronization.</p>
<p>If necessary, the caller can add concurrency by calling the function in a
separate goroutine. However, it is quite difficult (sometimes impossible) to
remove unnecessary concurrency at the caller side.</p>
<p>See also:</p>
<ul>
<li>“Rethinking Classical Concurrency Patterns”, talk by Bryan Mills:
    <a href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">slides</a>, <a href="https://www.youtube.com/watch?v=5zXAHh5tJqQ">video</a></li>
</ul>
<p><a id="type-aliases"></a></p>
<h3 id="type-aliases">Type aliases<a class="headerlink" href="#type-aliases" title="Permanent link">¶</a></h3>
<p><a id="TOC-TypeAliases"></a></p>
<p>Use a <em>type definition</em>, <code>type T1 T2</code>, to define a new type. Use a
<a href="http://golang.org/ref/spec#Type_declarations"><em>type alias</em></a>, <code>type T1 = T2</code>, to refer to an existing type without defining a
new type. Type aliases are rare; their primary use is to aid migrating packages
to new source code locations. Don’t use type aliasing when it is not needed.</p>
<p><a id="use-percent-q"></a></p>
<h3 id="use-q">Use %q<a class="headerlink" href="#use-q" title="Permanent link">¶</a></h3>
<p><a id="TOC-UsePercentQ"></a></p>
<p>Go’s format functions (<code>fmt.Printf</code> etc.) have a <code>%q</code> verb which prints strings
inside double-quotation marks.</p>
<pre><code class="language-go">// Good:
fmt.Printf("value %q looks like English text", someText)
</code></pre>
<p>Prefer using <code>%q</code> over doing the equivalent manually, using <code>%s</code>:</p>
<pre><code class="language-go">// Bad:
fmt.Printf("value \"%s\" looks like English text", someText)
// Avoid manually wrapping strings with single-quotes too:
fmt.Printf("value '%s' looks like English text", someText)
</code></pre>
<p>Using <code>%q</code> is recommended in output intended for humans where the input value
could possibly be empty or contain control characters. It can be very hard to
notice a silent empty string, but <code>""</code> stands out clearly as such.</p>
<p><a id="use-any"></a></p>
<h3 id="use-any">Use any<a class="headerlink" href="#use-any" title="Permanent link">¶</a></h3>
<p>Go 1.18 introduces an <code>any</code> type as an <a href="https://go.googlesource.com/proposal/+/master/design/18130-type-alias.md">alias</a> to <code>interface{}</code>. Because it is
an alias, <code>any</code> is equivalent to <code>interface{}</code> in many situations and in others
it is easily interchangeable via an explicit conversion. Prefer to use <code>any</code> in
new code.</p>
<h2 id="common-libraries">Common libraries<a class="headerlink" href="#common-libraries" title="Permanent link">¶</a></h2>
<p><a id="flags"></a></p>
<h3 id="flags">Flags<a class="headerlink" href="#flags" title="Permanent link">¶</a></h3>
<p><a id="TOC-Flags"></a></p>
<p>Go programs in the Google codebase use an internal variant of the
[standard <code>flag</code> package]. It has a similar interface but interoperates well
with internal Google systems. Flag names in Go binaries should prefer to use
underscores to separate words, though the variables that hold a flag’s value
should follow the standard Go name style (<a href="guide#mixed-caps">mixed caps</a>). Specifically, the flag
name should be in snake case, and the variable name should be the equivalent
name in camel case.</p>
<pre><code class="language-go">// Good:
var (
    pollInterval = flag.Duration("poll_interval", time.Minute, "Interval to use for polling.")
)
</code></pre>
<pre><code class="language-go">// Bad:
var (
    poll_interval = flag.Int("pollIntervalSeconds", 60, "Interval to use for polling in seconds.")
)
</code></pre>
<p>Flags must only be defined in <code>package main</code> or equivalent.</p>
<p>General-purpose packages should be configured using Go APIs, not by punching
through to the command-line interface; don’t let importing a library export new
flags as a side effect. That is, prefer explicit function arguments or struct
field assignment or much less frequently and under the strictest of scrutiny
exported global variables. In the extremely rare case that it is necessary to
break this rule, the flag name must clearly indicate the package that it
configures.</p>
<p>If your flags are global variables, place them in their own <code>var</code> group,
following the imports section.</p>
<p>There is additional discussion around best practices for creating <a href="best-practices#complex-clis">complex CLIs</a>
with subcommands.</p>
<p>See also:</p>
<ul>
<li><a href="https://abseil.io/tips/45">Tip of the Week #45: Avoid Flags, Especially in Library Code</a></li>
<li><a href="https://google.github.io/styleguide/go/index.html#gotip">Go Tip #10: Configuration Structs and Flags</a></li>
<li><a href="https://google.github.io/styleguide/go/index.html#gotip">Go Tip #80: Dependency Injection Principles</a></li>
</ul>
<p><a id="logging"></a></p>
<h3 id="logging">Logging<a class="headerlink" href="#logging" title="Permanent link">¶</a></h3>
<p>Go programs in the Google codebase use a variant of the
[standard <code>log</code> package]. It has a similar but more powerful interface and
interoperates well with internal Google systems. An open source version of this
library is available as [package <code>glog</code>], and open source Google projects may
use that, but this guide refers to it as <code>log</code> throughout.</p>
<p><strong>Note:</strong> For abnormal program exits, this library uses <code>log.Fatal</code> to abort
with a stacktrace, and <code>log.Exit</code> to stop without one. There is no <code>log.Panic</code>
function as in the standard library.</p>
<p><strong>Tip:</strong> <code>log.Info(v)</code> is equivalent <code>log.Infof("%v", v)</code>, and the same goes for
other logging levels. Prefer the non-formatting version when you have no
formatting to do.</p>
<p>See also:</p>
<ul>
<li>Best practices on <a href="best-practices#error-logging">logging errors</a> and
    <a href="best-practices#vlog">custom verbosily levels</a></li>
<li>When and how to use the log package to
    <a href="best-practices#checks-and-panics">stop the program</a></li>
</ul>
<p><a id="contexts"></a></p>
<h3 id="contexts">Contexts<a class="headerlink" href="#contexts" title="Permanent link">¶</a></h3>
<p><a id="TOC-Contexts"></a></p>
<p>Values of the [<code>context.Context</code>] type carry security credentials, tracing
information, deadlines, and cancellation signals across API and process
boundaries. Unlike C++ and Java, which in the Google codebase use thread-local
storage, Go programs pass contexts explicitly along the entire function call
chain from incoming RPCs and HTTP requests to outgoing requests.</p>
<p>When passed to a function or method, <code>context.Context</code> is always the first
parameter.</p>
<pre><code class="language-go">func F(ctx context.Context /* other arguments */) {}
</code></pre>
<p>Exceptions are:</p>
<ul>
<li>In an HTTP handler, where the context comes from
    <a href="https://pkg.go.dev/net/http#Request.Context"><code>req.Context()</code></a>.</li>
<li>
<p>In streaming RPC methods, where the context comes from the stream.</p>
<p>Code using gRPC streaming accesses a context from a <code>Context()</code> method in
the generated server type, which implements <code>grpc.ServerStream</code>. See
<a href="https://grpc.io/docs/languages/go/generated-code/">gRPC Generated Code documentation</a>.</p>
</li>
<li>
<p>In entrypoint functions (see below for examples of such functions), use
    <a href="https://pkg.go.dev/context/#Background"><code>context.Background()</code></a>.</p>
<ul>
<li>In binary targets: <code>main</code></li>
<li>In general purpose code and libraries: <code>init</code></li>
<li>In tests: <code>TestXXX</code>, <code>BenchmarkXXX</code>, <code>FuzzXXX</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: It is very rare for code in the middle of a callchain to require
creating a base context of its own using <code>context.Background()</code>. Always prefer
taking a context from your caller, unless it’s the wrong context.</p>
<p>You may come across server libraries (the implementation of Stubby, gRPC, or
HTTP in Google’s server framework for Go) that construct a fresh context
object per request. These contexts are immediately filled with information
from the incoming request, so that when passed to the request handler, the
context’s attached values have been propagated to it across the network
boundary from the client caller. Moreover, these contexts’ lifetimes are
scoped to that of the request: when the request is finished, the context is
cancelled.</p>
<p>Unless you are implementing a server framework, you shouldn’t create contexts
with <code>context.Background()</code> in library code. Instead, prefer using context
detachment, which is mentioned below, if there is an existing context
available. If you think you do need <code>context.Background()</code> outside of
entrypoint functions, discuss it with the Google Go style mailing list before
committing to an implementation.</p>
</blockquote>
<p>The convention that <code>context.Context</code> comes first in functions also applies to
test helpers.</p>
<pre><code class="language-go">// Good:
func readTestFile(ctx context.Context, t *testing.T, path string) string {}
</code></pre>
<p>Do not add a context member to a struct type. Instead, add a context parameter
to each method on the type that needs to pass it along. The one exception is for
methods whose signature must match an interface in the standard library or in a
third party library outside Google’s control. Such cases are very rare, and
should be discussed with the Google Go style mailing list before implementation
and readability review.</p>
<p>Code in the Google codebase that must spawn background operations which can run
after the parent context has been cancelled can use an internal package for
detachment. Follow <a href="https://github.com/golang/go/issues/40221">issue #40221</a> for
discussions on an open source alternative.</p>
<p>Since contexts are immutable, it is fine to pass the same context to multiple
calls that share the same deadline, cancellation signal, credentials, parent
trace, and so on.</p>
<p>See also:</p>
<ul>
<li><a href="https://go.dev/blog/context-and-structs">Contexts and structs</a></li>
</ul>
<p><a id="custom-contexts"></a></p>
<h4 id="custom-contexts">Custom contexts<a class="headerlink" href="#custom-contexts" title="Permanent link">¶</a></h4>
<p>Do not create custom context types or use interfaces other than
<code>context.Context</code> in function signatures. There are no exceptions to this rule.</p>
<p>Imagine if every team had a custom context. Every function call from package <code>p</code>
to package <code>q</code> would have to determine how to convert a <code>p.Context</code> to a
<code>q.Context</code>, for all pairs of packages <code>p</code> and <code>q</code>. This is impractical and
error-prone for humans, and it makes automated refactorings that add context
parameters nearly impossible.</p>
<p>If you have application data to pass around, put it in a parameter, in the
receiver, in globals, or in a <code>Context</code> value if it truly belongs there.
Creating your own context type is not acceptable since it undermines the ability
of the Go team to make Go programs work properly in production.</p>
<p><a id="crypto-rand"></a></p>
<h3 id="cryptorand">crypto/rand<a class="headerlink" href="#cryptorand" title="Permanent link">¶</a></h3>
<p><a id="TOC-CryptoRand"></a></p>
<p>Do not use package <code>math/rand</code> to generate keys, even throwaway ones. If
unseeded, the generator is completely predictable. Seeded with
<code>time.Nanoseconds()</code>, there are just a few bits of entropy. Instead, use
<code>crypto/rand</code>’s Reader, and if you need text, print to hexadecimal or base64.</p>
<pre><code class="language-go">// Good:
import (
    "crypto/rand"
    // "encoding/base64"
    // "encoding/hex"
    "fmt"

    // ...
)

func Key() string {
    buf := make([]byte, 16)
    if _, err := rand.Read(buf); err != nil {
        log.Fatalf("Out of randomness, should never happen: %v", err)
    }
    return fmt.Sprintf("%x", buf)
    // or hex.EncodeToString(buf)
    // or base64.StdEncoding.EncodeToString(buf)
}
</code></pre>
<p><strong>Note:</strong> <code>log.Fatalf</code> is not the standard library log. See [#logging].</p>
<p><a id="useful-test-failures"></a></p>
<h2 id="useful-test-failures">Useful test failures<a class="headerlink" href="#useful-test-failures" title="Permanent link">¶</a></h2>
<p><a id="TOC-UsefulTestFailures"></a></p>
<p>It should be possible to diagnose a test’s failure without reading the test’s
source. Tests should fail with helpful messages detailing:</p>
<ul>
<li>What caused the failure</li>
<li>What inputs resulted in an error</li>
<li>The actual result</li>
<li>What was expected</li>
</ul>
<p>Specific conventions for achieving this goal are outlined below.</p>
<p><a id="assert"></a></p>
<h3 id="assertion-libraries">Assertion libraries<a class="headerlink" href="#assertion-libraries" title="Permanent link">¶</a></h3>
<p><a id="TOC-Assert"></a></p>
<p>Do not create “assertion libraries” as helpers for testing.</p>
<p>Assertion libraries are libraries that attempt to combine the validation and
production of failure messages within a test (though the same pitfalls can apply
to other test helpers as well). For more on the distinction between test helpers
and assertion libraries, see <a href="best-practices#test-functions">best practices</a>.</p>
<pre><code class="language-go">// Bad:
var obj BlogPost

assert.IsNotNil(t, "obj", obj)
assert.StringEq(t, "obj.Type", obj.Type, "blogPost")
assert.IntEq(t, "obj.Comments", obj.Comments, 2)
assert.StringNotEq(t, "obj.Body", obj.Body, "")
</code></pre>
<p>Assertion libraries tend to either stop the test early (if <code>assert</code> calls
<code>t.Fatalf</code> or <code>panic</code>) or omit relevant information about what the test got
right:</p>
<pre><code class="language-go">// Bad:
package assert

func IsNotNil(t *testing.T, name string, val interface{}) {
    if val == nil {
        t.Fatalf("data %s = nil, want not nil", name)
    }
}

func StringEq(t *testing.T, name, got, want string) {
    if got != want {
        t.Fatalf("data %s = %q, want %q", name, got, want)
    }
}
</code></pre>
<p>Complex assertion functions often do not provide <a href="#useful-test-failures">useful failure messages</a> and
context that exists within the test function. Too many assertion functions and
libraries lead to a fragmented developer experience: which assertion library
should I use, what style of output format should it emit, etc.? Fragmentation
produces unnecessary confusion, especially for library maintainers and authors
of large-scale changes, who are responsible for fixing potential downstream
breakages. Instead of creating a domain-specific language for testing, use Go
itself.</p>
<p>Assertion libraries often factor out comparisons and equality checks. Prefer
using standard libraries such as [<code>cmp</code>] and [<code>fmt</code>] instead:</p>
<pre><code class="language-go">// Good:
var got BlogPost

want := BlogPost{
    Comments: 2,
    Body:     "Hello, world!",
}

if !cmp.Equal(got, want) {
    t.Errorf("blog post = %v, want = %v", got, want)
}
</code></pre>
<p>For more domain-specific comparison helpers, prefer returning a value or an
error that can be used in the test’s failure message instead of passing
<code>*testing.T</code> and calling its error reporting methods:</p>
<pre><code class="language-go">// Good:
func postLength(p BlogPost) int { return len(p.Body) }

func TestBlogPost_VeritableRant(t *testing.T) {
    post := BlogPost{Body: "I am Gunnery Sergeant Hartman, your senior drill instructor."}

    if got, want := postLength(post), 60; got != want {
        t.Errorf("length of post = %v, want %v", got, want)
    }
}
</code></pre>
<p><strong>Best Practice:</strong> Were <code>postLength</code> non-trivial, it would make sense to test it
directly, independently of any tests that use it.</p>
<p>See also:</p>
<ul>
<li><a href="#types-of-equality">Equality comparison and diffs</a></li>
<li><a href="#print-diffs">Print diffs</a></li>
<li>For more on the distinction between test helpers and assertion helpers, see
    <a href="best-practices#test-functions">best practices</a></li>
</ul>
<p><a id="identify-the-function"></a></p>
<h3 id="identify-the-function">Identify the function<a class="headerlink" href="#identify-the-function" title="Permanent link">¶</a></h3>
<p>In most tests, failure messages should include the name of the function that
failed, even though it seems obvious from the name of the test function.
Specifically, your failure message should be <code>YourFunc(%v) = %v, want %v</code>
instead of just <code>got %v, want %v</code>.</p>
<p><a id="identify-the-input"></a></p>
<h3 id="identify-the-input">Identify the input<a class="headerlink" href="#identify-the-input" title="Permanent link">¶</a></h3>
<p>In most tests, failure messages should include the function inputs if they are
short. If the relevant properties of the inputs are not obvious (for example,
because the inputs are large or opaque), you should name your test cases with a
description of what’s being tested and print the description as part of your
error message.</p>
<p><a id="got-before-want"></a></p>
<h3 id="got-before-want">Got before want<a class="headerlink" href="#got-before-want" title="Permanent link">¶</a></h3>
<p>Test outputs should include the actual value that the function returned before
printing the value that was expected. A standard format for printing test
outputs is <code>YourFunc(%v) = %v, want %v</code>. Where you would write “actual” and
“expected”, prefer using the words “got” and “want”, respectively.</p>
<p>For diffs, directionality is less apparent, and as such it is important to
include a key to aid in interpreting the failure. See the
<a href="#print-diffs">section on printing diffs</a>. Whichever diff order you use in your failure
messages, you should explicitly indicate it as a part of the failure message,
because existing code is inconsistent about the ordering.</p>
<p><a id="compare-full-structures"></a></p>
<h3 id="full-structure-comparisons">Full structure comparisons<a class="headerlink" href="#full-structure-comparisons" title="Permanent link">¶</a></h3>
<p>If your function returns a struct (or any data type with multiple fields such as
slices, arrays, and maps), avoid writing test code that performs a hand-coded
field-by-field comparison of the struct. Instead, construct the data that you’re
expecting your function to return, and compare directly using a
<a href="#types-of-equality">deep comparison</a>.</p>
<p><strong>Note:</strong> This does not apply if your data contains irrelevant fields that
obscure the intention of the test.</p>
<p>If your struct needs to be compared for approximate (or equivalent kind of
semantic) equality or it contains fields that cannot be compared for equality
(e.g., if one of the fields is an <code>io.Reader</code>), tweaking a [<code>cmp.Diff</code>] or
[<code>cmp.Equal</code>] comparison with [<code>cmpopts</code>] options such as
[<code>cmpopts.IgnoreInterfaces</code>] may meet your needs
(<a href="https://play.golang.org/p/vrCUNVfxsvF">example</a>).</p>
<p>If your function returns multiple return values, you don’t need to wrap those in
a struct before comparing them. Just compare the return values individually and
print them.</p>
<pre><code class="language-go">// Good:
val, multi, tail, err := strconv.UnquoteChar(`\"Fran &amp; Freddie's Diner\"`, '"')
if err != nil {
  t.Fatalf(...)
}
if val != `"` {
  t.Errorf(...)
}
if multi {
  t.Errorf(...)
}
if tail != `Fran &amp; Freddie's Diner"` {
  t.Errorf(...)
}
</code></pre>
<p><a id="compare-stable-results"></a></p>
<h3 id="compare-stable-results">Compare stable results<a class="headerlink" href="#compare-stable-results" title="Permanent link">¶</a></h3>
<p>Avoid comparing results that may depend on output stability of a package that
you do not own. Instead, the test should compare on semantically relevant
information that is stable and resistant to changes in dependencies. For
functionality that returns a formatted string or serialized bytes, it is
generally not safe to assume that the output is stable.</p>
<p>For example, [<code>json.Marshal</code>] can change (and has changed in the past) the
specific bytes that it emits. Tests that perform string equality on the JSON
string may break if the <code>json</code> package changes how it serializes the bytes.
Instead, a more robust test would parse the contents of the JSON string and
ensure that it is semantically equivalent to some expected data structure.</p>
<p><a id="keep-going"></a></p>
<h3 id="keep-going">Keep going<a class="headerlink" href="#keep-going" title="Permanent link">¶</a></h3>
<p>Tests should keep going for as long as possible, even after a failure, in order
to print out all of the failed checks in a single run. This way, a developer who
is fixing the failing test doesn’t have to re-run the test after fixing each bug
to find the next bug.</p>
<p>Prefer calling <code>t.Error</code> over <code>t.Fatal</code> for reporting a mismatch. When comparing
several different properties of a function’s output, use <code>t.Error</code> for each of
those comparisons.</p>
<p>Calling <code>t.Fatal</code> is primarily useful for reporting an unexpected error
condition, when subsequent comparison failures are not going to be meaningful.</p>
<p>For table-driven test, consider using subtests and use <code>t.Fatal</code> rather than
<code>t.Error</code> and <code>continue</code>. See also
<a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #25: Subtests: Making Your Tests Lean</a>.</p>
<p><strong>Best practice:</strong> For more discussion about when <code>t.Fatal</code> should be used, see
<a href="best-practices#t-fatal">best practices</a>.</p>
<p><a id="types-of-equality"></a></p>
<h3 id="equality-comparison-and-diffs">Equality comparison and diffs<a class="headerlink" href="#equality-comparison-and-diffs" title="Permanent link">¶</a></h3>
<p>The <code>==</code> operator evaluates equality using <a href="http://golang.org/ref/spec#Comparison_operators">language-defined comparisons</a>.
Scalar values (numbers, booleans, etc) are compared based on their values, but
only some structs and interfaces can be compared in this way. Pointers are
compared based on whether they point to the same variable, rather than based on
the equality of the values to which they point.</p>
<p>The [<code>cmp</code>] package can compare more complex data structures not appropriately
handled by <code>==</code>, such as slices. Use [<code>cmp.Equal</code>] for equality comparison and
[<code>cmp.Diff</code>] to obtain a human-readable diff between objects.</p>
<pre><code class="language-go">// Good:
want := &amp;Doc{
    Type:     "blogPost",
    Comments: 2,
    Body:     "This is the post body.",
    Authors:  []string{"isaac", "albert", "emmy"},
}
if !cmp.Equal(got, want) {
    t.Errorf("AddPost() = %+v, want %+v", got, want)
}
</code></pre>
<p>As a general-purpose comparison library, <code>cmp</code> may not know how to compare
certain types. For example, it can only compare protocol buffer messages if
passed the [<code>protocmp.Transform</code>] option.</p>
<!-- The order of want and got here is deliberate. See comment in #print-diffs. -->
<pre><code class="language-go">// Good:
if diff := cmp.Diff(want, got, protocmp.Transform()); diff != "" {
    t.Errorf("Foo() returned unexpected difference in protobuf messages (-want +got):\n%s", diff)
}
</code></pre>
<p>Although the <code>cmp</code> package is not part of the Go standard library, it is
maintained by the Go team and should produce stable equality results over time.
It is user-configurable and should serve most comparison needs.</p>
<p>Existing code may make use of the following older libraries, and may continue
using them for consistency:</p>
<ul>
<li>[<code>pretty</code>] produces aesthetically pleasing difference reports. However, it
    quite deliberately considers values that have the same visual representation
    as equal. In particular, <code>pretty</code> does not catch differences between nil
    slices and empty ones, is not sensitive to different interface
    implementations with identical fields, and it is possible to use a nested
    map as the basis for comparison with a struct value. It also serializes the
    entire value into a string before producing a diff, and as such is not a
    good choice for comparing large values. By default, it compares unexported
    fields, which makes it sensitive to changes in implementation details in
    your dependencies. For this reason, it is not appropriate to use <code>pretty</code> on
    protobuf messages.</li>
</ul>
<p>Prefer using <code>cmp</code> for new code, and it is worth considering updating older code
to use <code>cmp</code> where and when it is practical to do so.</p>
<p>Older code may use the standard library <code>reflect.DeepEqual</code> function to compare
complex structures. <code>reflect.DeepEqual</code> should not be used for checking
equality, as it is sensitive to changes in unexported fields and other
implementation details. Code that is using <code>reflect.DeepEqual</code> should be updated
to one of the above libraries.</p>
<p><strong>Note:</strong> The <code>cmp</code> package is designed for testing, rather than production use.
As such, it may panic when it suspects that a comparison is performed
incorrectly to provide instruction to users on how to improve the test to be
less brittle. Given cmp’s propensity towards panicking, it makes it unsuitable
for code that is used in production as a spurious panic may be fatal.</p>
<p><a id="level-of-detail"></a></p>
<h3 id="level-of-detail">Level of detail<a class="headerlink" href="#level-of-detail" title="Permanent link">¶</a></h3>
<p>The conventional failure message, which is suitable for most Go tests, is
<code>YourFunc(%v) = %v, want %v</code>. However, there are cases that may call for more or
less detail:</p>
<ul>
<li>Tests performing complex interactions should describe the interactions too.
    For example, if the same <code>YourFunc</code> is called several times, identify which
    call failed the test. If it’s important to know any extra state of the
    system, include that in the failure output (or at least in the logs).</li>
<li>If the data is a complex struct with significant boilerplate, it is
    acceptable to describe only the important parts in the message, but do not
    overly obscure the data.</li>
<li>Setup failures do not require the same level of detail. If a test helper
    populates a Spanner table but Spanner was down, you probably don’t need to
    include which test input you were going to store in the database.
    <code>t.Fatalf("Setup: Failed to set up test database: %s", err)</code> is usually
    helpful enough to resolve the issue.</li>
</ul>
<p><strong>Tip:</strong> Make your failure mode trigger during development. Review what the
failure message looks like and whether a maintainer can effectively deal with
the failure.</p>
<p>There are some techniques for reproducing test inputs and outputs clearly:</p>
<ul>
<li>When printing string data, <a href="#use-percent-q"><code>%q</code> is often useful</a> to
    emphasize that the value is important and to more easily spot bad values.</li>
<li>When printing (small) structs, <code>%+v</code> can be more useful than <code>%v</code>.</li>
<li>When validation of larger values fails, <a href="#print-diffs">printing a diff</a> can
    make it easier to understand the failure.</li>
</ul>
<p><a id="print-diffs"></a></p>
<h3 id="print-diffs">Print diffs<a class="headerlink" href="#print-diffs" title="Permanent link">¶</a></h3>
<p>If your function returns large output then it can be hard for someone reading
the failure message to find the differences when your test fails. Instead of
printing both the returned value and the wanted value, make a diff.</p>
<p>To compute diffs for such values, <code>cmp.Diff</code> is preferred, particularly for new
tests and new code, but other tools may be used. See <a href="#types-of-equality">types of equality</a> for
guidance regarding the strengths and weaknesses of each function.</p>
<ul>
<li>
<p>[<code>cmp.Diff</code>]</p>
</li>
<li>
<p>[<code>pretty.Compare</code>]</p>
</li>
</ul>
<p>You can use the [<code>diff</code>] package to compare multi-line strings or lists of
strings. You can use this as a building block for other kinds of diffs.</p>
<p>Add some text to your failure message explaining the direction of the diff.</p>
<!--
The reversed order of want and got in these examples is intentional, as this is
the prevailing order across the Google codebase. The lack of a stance on which
order to use is also intentional, as there is no consensus which is
"most readable."


-->
<ul>
<li>
<p>Something like <code>diff (-want +got)</code> is good when you’re using the <code>cmp</code>,
    <code>pretty</code>, and <code>diff</code> packages (if you pass <code>(want, got)</code> to the function),
    because the <code>-</code> and <code>+</code> that you add to your format string will match the
    <code>-</code> and <code>+</code> that actually appear at the beginning of the diff lines. If you
    pass <code>(got, want)</code> to your function, the correct key would be <code>(-got +want)</code>
    instead.</p>
</li>
<li>
<p>The <code>messagediff</code> package uses a different output format, so the message
    <code>diff (want -&gt; got)</code> is appropriate when you’re using it (if you pass
    <code>(want, got)</code> to the function), because the direction of the arrow will
    match the direction of the arrow in the “modified” lines.</p>
</li>
</ul>
<p>The diff will span multiple lines, so you should print a newline before you
print the diff.</p>
<p><a id="test-error-semantics"></a></p>
<h3 id="test-error-semantics">Test error semantics<a class="headerlink" href="#test-error-semantics" title="Permanent link">¶</a></h3>
<p>When a unit test performs string comparisons or uses a vanilla <code>cmp</code> to check
that particular kinds of errors are returned for particular inputs, you may find
that your tests are brittle if any of those error messages are reworded in the
future. Since this has the potential to turn your unit test into a change
detector (see <a href="https://testing.googleblog.com/2015/01/testing-on-toilet-change-detector-tests.html">TotT: Change-Detector Tests Considered Harmful</a> ),
don’t use string comparison to check what type of error your function returns.
However, it is permissible to use string comparisons to check that error
messages coming from the package under test satisfy certain properties, for
example, that it includes the parameter name.</p>
<p>Error values in Go typically have a component intended for human eyes and a
component intended for semantic control flow. Tests should seek to only test
semantic information that can be reliably observed, rather than display
information that is intended for human debugging, as this is often subject to
future changes. For guidance on constructing errors with semantic meaning see
<a href="best-practices#error-handling">best-practices regarding errors</a>. If an error
with insufficient semantic information is coming from a dependency outside your
control, consider filing a bug against the owner to help improve the API, rather
than relying on parsing the error message.</p>
<p>Within unit tests, it is common to only care whether an error occurred or not.
If so, then it is sufficient to only test whether the error was non-nil when you
expected an error. If you would like to test that the error semantically matches
some other error, then consider using <code>cmp</code> with [<code>cmpopts.EquateErrors</code>].</p>
<blockquote>
<p><strong>Note:</strong> If a test uses [<code>cmpopts.EquateErrors</code>] but all of its <code>wantErr</code>
values are either <code>nil</code> or <code>cmpopts.AnyError</code>, then using <code>cmp</code> is
<a href="guide#least-mechanism">unnecessary mechanism</a>. Simplify the code by making
the want field a <code>bool</code>. You can then use a simple comparison with <code>!=</code>.</p>
<p><code>go
// Good:
gotErr := f(test.input) != nil
if gotErr != test.wantErr {
    t.Errorf("f(%q) returned err = %v, want error presence = %v", test.input, gotErr, test.wantErr)
}</code></p>
</blockquote>
<p>See also
<a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #13: Designing Errors for Checking</a>.</p>
<p><a id="test-structure"></a></p>
<h2 id="test-structure">Test structure<a class="headerlink" href="#test-structure" title="Permanent link">¶</a></h2>
<p><a id="subtests"></a></p>
<h3 id="subtests">Subtests<a class="headerlink" href="#subtests" title="Permanent link">¶</a></h3>
<p>The standard Go testing library offers a facility to <a href="https://pkg.go.dev/testing#hdr-Subtests_and_Sub_benchmarks">define subtests</a>. This
allows flexibility in setup and cleanup, controlling parallelism, and test
filtering. Subtests can be useful (particularly for table-driven tests), but
using them is not mandatory. See also the
<a href="https://blog.golang.org/subtests">Go blog post about subtests</a>.</p>
<p>Subtests should not depend on the execution of other cases for success or
initial state, because subtests are expected to be able to be run individually
with using <code>go test -run</code> flags or with Bazel <a href="https://bazel.build/docs/user-manual#test-filter">test filter</a> expressions.</p>
<p><a id="subtest-names"></a></p>
<h4 id="subtest-names">Subtest names<a class="headerlink" href="#subtest-names" title="Permanent link">¶</a></h4>
<p>Name your subtest such that it is readable in test output and useful on the
command line for users of test filtering. When you use <code>t.Run</code> to create a
subtest, the first argument is used as a descriptive name for the test. To
ensure that test results are legible to humans reading the logs, choose subtest
names that will remain useful and readable after escaping. Think of subtest
names more like a function identifier than a prose description. The test runner
replaces spaces with underscores, and escapes non-printing characters. If your
test data benefits from a longer description, consider putting the description
in a separate field (perhaps to be printed using <code>t.Log</code> or alongside failure
messages).</p>
<p>Subtests may be run individually using flags to the <a href="https://golang.org/cmd/go/#hdr-Testing_flags">Go test runner</a> or Bazel
<a href="https://bazel.build/docs/user-manual#test-filter">test filter</a>, so choose descriptive names that are also easy to type.</p>
<blockquote>
<p><strong>Warning:</strong> Slash characters are particularly unfriendly in subtest names,
since they have <a href="https://blog.golang.org/subtests#:~:text=Perhaps%20a%20bit,match%20any%20tests">special meaning for test filters</a>.</p>
<blockquote>
<p>```sh</p>
<h1 id="bad">Bad:<a class="headerlink" href="#bad" title="Permanent link">¶</a></h1>
<h1 id="assuming-testtime-and-trunamericanew_york">Assuming TestTime and t.Run(“America/New_York”, …)<a class="headerlink" href="#assuming-testtime-and-trunamericanew_york" title="Permanent link">¶</a></h1>
<p>bazel test :mytest –test_filter=”Time/New_York”    # Runs nothing!
bazel test :mytest –test_filter=”Time//New_York”   # Correct, but awkward.
```</p>
</blockquote>
</blockquote>
<p>To <a href="#identify-the-input">identify the inputs</a> of the function, include them in the test’s failure
messages, where they won’t be escaped by the test runner.</p>
<pre><code class="language-go">// Good:
func TestTranslate(t *testing.T) {
    data := []struct {
        name, desc, srcLang, dstLang, srcText, wantDstText string
    }{
        {
            name:        "hu=en_bug-1234",
            desc:        "regression test following bug 1234. contact: cleese",
            srcLang:     "hu",
            srcText:     "cigarettát és egy öngyújtót kérek",
            dstLang:     "en",
            wantDstText: "cigarettes and a lighter please",
        }, // ...
    }
    for _, d := range data {
        t.Run(d.name, func(t *testing.T) {
            got := Translate(d.srcLang, d.dstLang, d.srcText)
            if got != d.wantDstText {
                t.Errorf("%s\nTranslate(%q, %q, %q) = %q, want %q",
                    d.desc, d.srcLang, d.dstLang, d.srcText, got, d.wantDstText)
            }
        })
    }
}
</code></pre>
<p>Here are a few examples of things to avoid:</p>
<pre><code class="language-go">// Bad:
// Too wordy.
t.Run("check that there is no mention of scratched records or hovercrafts", ...)
// Slashes cause problems on the command line.
t.Run("AM/PM confusion", ...)
</code></pre>
<p><a id="table-driven-tests"></a></p>
<h3 id="table-driven-tests">Table-driven tests<a class="headerlink" href="#table-driven-tests" title="Permanent link">¶</a></h3>
<p>Use table-driven tests when many different test cases can be tested using
similar testing logic.</p>
<ul>
<li>When testing whether the actual output of a function is equal to the
    expected output. For example, the many [tests of <code>fmt.Sprintf</code>] or the
    minimal snippet below.</li>
<li>When testing whether the outputs of a function always conform to the same
    set of invariants. For example, [tests for <code>net.Dial</code>].</li>
</ul>
<p>Here is the minimal structure of a table-driven test, copied from the standard
<code>strings</code> library. If needed, you may use different names, move the test slice
into the test function, or add extra facilities such as subtests or setup and
cleanup functions. Always keep <a href="#useful-test-failures">useful test failures</a> in
mind.</p>
<pre><code class="language-go">// Good:
var compareTests = []struct {
    a, b string
    i    int
}{
    {"", "", 0},
    {"a", "", 1},
    {"", "a", -1},
    {"abc", "abc", 0},
    {"ab", "abc", -1},
    {"abc", "ab", 1},
    {"x", "ab", 1},
    {"ab", "x", -1},
    {"x", "a", 1},
    {"b", "x", -1},
    // test runtime·memeq's chunked implementation
    {"abcdefgh", "abcdefgh", 0},
    {"abcdefghi", "abcdefghi", 0},
    {"abcdefghi", "abcdefghj", -1},
}

func TestCompare(t *testing.T) {
    for _, tt := range compareTests {
        cmp := Compare(tt.a, tt.b)
        if cmp != tt.i {
            t.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp)
        }
    }
}
</code></pre>
<p><strong>Note</strong>: The failure messages in this example above fulfill the guidance to
<a href="#identify-the-function">identify the function</a> and
<a href="#identify-the-input">identify the input</a>. There’s no need to
<a href="#table-tests-identifying-the-row">identify the row numerically</a>.</p>
<p>When some test cases need to be checked using different logic from other test
cases, it is more appropriate to write multiple test functions, as explained in
<a href="https://google.github.io/styleguide/go/index.html#gotip">GoTip #50: Disjoint Table Tests</a>. The logic of your test code can get difficult
to understand when each entry in a table has its own different conditional logic
to check each output for its inputs. If test cases have different logic but
identical setup, a sequence of <a href="#subtests">subtests</a> within a single test
function might make sense.</p>
<p>You can combine table-driven tests with multiple test functions. For example,
when testing that a function’s output exactly matches the expected output and
that the function returns a non-nil error for an invalid input, then writing two
separate table-driven test functions is the best approach: one for normal
non-error outputs, and one for error outputs.</p>
<p><a id="table-tests-data-driven"></a></p>
<h4 id="data-driven-test-cases">Data-driven test cases<a class="headerlink" href="#data-driven-test-cases" title="Permanent link">¶</a></h4>
<p>Table test rows can sometimes become complicated, with the row values dictating
conditional behavior inside the test case. The extra clarity from the
duplication between the test cases is necessary for readability.</p>
<pre><code class="language-go">// Good:
type decodeCase struct {
    name   string
    input  string
    output string
    err    error
}

func TestDecode(t *testing.T) {
    // setupCodex is slow as it creates a real Codex for the test.
    codex := setupCodex(t)

    var tests []decodeCase // rows omitted for brevity

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            output, err := Decode(test.input, codex)
            if got, want := output, test.output; got != want {
                t.Errorf("Decode(%q) = %v, want %v", test.input, got, want)
            }
            if got, want := err, test.err; !cmp.Equal(got, want) {
                t.Errorf("Decode(%q) err %q, want %q", test.input, got, want)
            }
        })
    }
}

func TestDecodeWithFake(t *testing.T) {
    // A fakeCodex is a fast approximation of a real Codex.
    codex := newFakeCodex()

    var tests []decodeCase // rows omitted for brevity

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            output, err := Decode(test.input, codex)
            if got, want := output, test.output; got != want {
                t.Errorf("Decode(%q) = %v, want %v", test.input, got, want)
            }
            if got, want := err, test.err; !cmp.Equal(got, want) {
                t.Errorf("Decode(%q) err %q, want %q", test.input, got, want)
            }
        })
    }
}
</code></pre>
<p>In the counterexample below, note how hard it is to distinguish between which
type of <code>Codex</code> is used per test case in the case setup. (The highlighted parts
run afoul of the advice from <a href="https://testing.googleblog.com/2008/09/tott-data-driven-traps.html">TotT: Data Driven Traps!</a> .)</p>
<pre><code class="language-go">// Bad:
type decodeCase struct {
  name   string
  input  string
  codex  testCodex
  output string
  err    error
}

type testCodex int

const (
  fake testCodex = iota
  prod
)

func TestDecode(t *testing.T) {
  var tests []decodeCase // rows omitted for brevity

  for _, test := tests {
    t.Run(test.name, func(t *testing.T) {
      var codex Codex
      switch test.codex {
      case fake:
        codex = newFakeCodex()
      case prod:
        codex = setupCodex(t)
      default:
        t.Fatalf("unknown codex type: %v", codex)
      }
      output, err := Decode(test.input, codex)
      if got, want := output, test.output; got != want {
        t.Errorf("Decode(%q) = %q, want %q", test.input, got, want)
      }
      if got, want := err, test.err; !cmp.Equal(got, want) {
        t.Errorf("Decode(%q) err %q, want %q", test.input, got, want)
      }
    })
  }
}
</code></pre>
<p><a id="table-tests-identifying-the-row"></a></p>
<h4 id="identifying-the-row">Identifying the row<a class="headerlink" href="#identifying-the-row" title="Permanent link">¶</a></h4>
<p>Do not use the index of the test in the test table as a substitute for naming
your tests or printing the inputs. Nobody wants to go through your test table
and count the entries in order to figure out which test case is failing.</p>
<pre><code class="language-go">// Bad:
tests := []struct {
    input, want string
}{
    {"hello", "HELLO"},
    {"wORld", "WORLD"},
}
for i, d := range tests {
    if strings.ToUpper(d.input) != d.want {
        t.Errorf("failed on case #%d", i)
    }
}
</code></pre>
<p>Add a test description to your test struct and print it along failure messages.
When using subtests, your subtest name should be effective in identifying the
row.</p>
<p><strong>Important:</strong> Even though <code>t.Run</code> scopes the output and execution, you must
always <a href="#identify-the-input">identify the input</a>. The table test row names must follow the
<a href="#subtest-names">subtest naming</a> guidance.</p>
<p><a id="mark-test-helpers"></a></p>
<h3 id="test-helpers">Test helpers<a class="headerlink" href="#test-helpers" title="Permanent link">¶</a></h3>
<p>A test helper is a function that performs a setup or cleanup task. All failures
that occur in test helpers are expected to be failures of the environment (not
from the code under test) — for example when a test database cannot be started
because there are no more free ports on this machine.</p>
<p>If you pass a <code>*testing.T</code>, call [<code>t.Helper</code>] to attribute failures in the test
helper to the line where the helper is called. This parameter should come after
a <a href="#contexts">context</a> parameter, if present, and before any remaining
parameters.</p>
<pre><code class="language-go">// Good:
func TestSomeFunction(t *testing.T) {
    golden := readFile(t, "testdata/golden-result.txt")
    // ... tests against golden ...
}

// readFile returns the contents of a data file.
// It must only be called from the same goroutine as started the test.
func readFile(t *testing.T, filename string) string {
    t.Helper()
    contents, err := runfiles.ReadFile(filename)
    if err != nil {
        t.Fatal(err)
    }
    return string(contents)
}
</code></pre>
<p>Do not use this pattern when it obscures the connection between a test failure
and the conditions that led to it. Specifically, the guidance about
<a href="#assert">assert libraries</a> still applies, and [<code>t.Helper</code>] should not be used
to implement such libraries.</p>
<p><strong>Tip:</strong> For more on the distinction between test helpers and assertion helpers,
see <a href="best-practices#test-functions">best practices</a>.</p>
<p>Although the above refers to <code>*testing.T</code>, much of the advice stays the same for
benchmark and fuzz helpers.</p>
<p><a id="test-package"></a></p>
<h3 id="test-package">Test package<a class="headerlink" href="#test-package" title="Permanent link">¶</a></h3>
<p><a id="TOC-TestPackage"></a></p>
<p><a id="test-same-package"></a></p>
<h4 id="tests-in-the-same-package">Tests in the same package<a class="headerlink" href="#tests-in-the-same-package" title="Permanent link">¶</a></h4>
<p>Tests may be defined in the same package as the code being tested.</p>
<p>To write a test in the same package:</p>
<ul>
<li>Place the tests in a <code>foo_test.go</code> file</li>
<li>Use <code>package foo</code> for the test file</li>
<li>Do not explicitly import the package to be tested</li>
</ul>
<pre><code class="language-build"># Good:
go_library(
    name = "foo",
    srcs = ["foo.go"],
    deps = [
        ...
    ],
)

go_test(
    name = "foo_test",
    size = "small",
    srcs = ["foo_test.go"],
    library = ":foo",
    deps = [
        ...
    ],
)
</code></pre>
<p>A test in the same package can access unexported identifiers in the package.
This may enable better test coverage and more concise tests. Be aware that any
<a href="#examples">examples</a> declared in the test will not have the package names that a user will
need in their code.</p>
<p><a id="test-different-package"></a></p>
<h4 id="tests-in-a-different-package">Tests in a different package<a class="headerlink" href="#tests-in-a-different-package" title="Permanent link">¶</a></h4>
<p>It is not always appropriate or even possible to define a test in the same
package as the code being tested. In these cases, use a package name with the
<code>_test</code> suffix. This is an exception to the “no underscores” rule to
<a href="#package-names">package names</a>. For example:</p>
<ul>
<li>
<p>If an integration test does not have an obvious library that it belongs to</p>
<p>```go
// Good:
package gmailintegration_test</p>
<p>import “testing”
```</p>
</li>
<li>
<p>If defining the tests in the same package results in circular dependencies</p>
<p>```go
// Good:
package fireworks_test</p>
<p>import (
  “fireworks”
  “fireworkstestutil” // fireworkstestutil also imports fireworks
)
```</p>
</li>
</ul>
<p><a id="use-package-testing"></a></p>
<h3 id="use-package-testing">Use package <code>testing</code><a class="headerlink" href="#use-package-testing" title="Permanent link">¶</a></h3>
<p>The Go standard library provides the [<code>testing</code> package]. This is the only
testing framework permitted for Go code in the Google codebase. In particular,
<a href="#assert">assertion libraries</a> and third-party testing frameworks are not
allowed.</p>
<p>The <code>testing</code> package provides a minimal but complete set of functionality for
writing good tests:</p>
<ul>
<li>Top-level tests</li>
<li>Benchmarks</li>
<li><a href="https://blog.golang.org/examples">Runnable examples</a></li>
<li>Subtests</li>
<li>Logging</li>
<li>Failures and fatal failures</li>
</ul>
<p>These are designed to work cohesively with core language features like
<a href="https://go.dev/ref/spec#Composite_literals">composite literal</a> and <a href="https://go.dev/ref/spec#If_statements">if-with-initializer</a> syntax to enable test authors to
write [clear, readable, and maintainable tests].</p>
<p><a id="non-decisions"></a></p>
<h2 id="non-decisions">Non-decisions<a class="headerlink" href="#non-decisions" title="Permanent link">¶</a></h2>
<p>A style guide cannot enumerate positive prescriptions for all matters, nor can
it enumerate all matters about which it does not offer an opinion. That said,
here are a few things where the readability community has previously debated and
has not achieved consensus about.</p>
<ul>
<li><strong>Local variable initialization with zero value</strong>. <code>var i int</code> and <code>i := 0</code>
    are equivalent. See also <a href="https://google.github.io/styleguide/go/best-practices#vardeclinitialization">initialization best practices</a>.</li>
<li><strong>Empty composite literal vs. <code>new</code> or <code>make</code></strong>. <code>&amp;File{}</code> and <code>new(File)</code>
    are equivalent. So are <code>map[string]bool{}</code> and <code>make(map[string]bool)</code>. See
    also <a href="https://google.github.io/styleguide/go/best-practices#vardeclcomposite">composite declaration best practices</a>.</li>
<li><strong>got, want argument ordering in cmp.Diff calls</strong>. Be locally consistent,
    and <a href="#print-diffs">include a legend</a> in your failure message.</li>
<li><strong><code>errors.New</code> vs <code>fmt.Errorf</code> on non-formatted strings</strong>.
    <code>errors.New("foo")</code> and <code>fmt.Errorf("foo")</code> may be used interchangeably.</li>
</ul>
<p>If there are special circumstances where they come up again, the readability
mentor might make an optional comment, but in general the author is free to pick
the style they prefer in the given situation.</p>
<p>Naturally, if anything not covered by the style guide does need more discussion,
authors are welcome to ask – either in the specific review, or on internal
message boards.</p>
<!--
-->
<p>{% endraw %}</p></div>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
<button class="md-top md-icon" data-md-component="top" hidden="" type="button">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"></path></svg>
  Back to top
</button>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../../../../..", "features": ["navigation.instant", "navigation.tabs", "navigation.top", "navigation.prune", "search.highlight", "search.suggest", "content.code.annotate", "content.code.copy"], "search": "../../../../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
<script src="../../../../../assets/javascripts/bundle.c8b220af.min.js"></script>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</body>
</html>